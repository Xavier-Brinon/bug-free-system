#+title: Architecture Research: BookTab
#+author: BookTab
#+date: [2026-02-25 Tue]
#+startup: indent
#+options: toc:3 num:t ^:{}

- *Domain* :: Firefox browser extension -- new tab page replacement with local
  data storage
- *Researched* :: [2026-02-25 Tue]
- *Confidence* :: HIGH -- all structural claims sourced from MDN official docs
  (updated Jan--Aug 2025)

* Standard architecture

** System overview

For a Firefox new tab extension with local-only storage, there are two viable
architectures. BookTab uses *Architecture A* (no background script) because
the new tab page has full WebExtension API access and can read/write
~browser.storage.local~ directly.

#+begin_src mermaid :file ./images/arch-system-overview.svg :theme neutral
graph TD
    M["manifest.json\nchrome_url_overrides.newtab\npermissions: storage"]
    M --> H["newtab/newtab.html\n(Extension Page — privileged)"]

    subgraph Page["Extension Page (privileged)"]
        UI["UI Layer\n(HTML/CSS)"]
        APP["App Logic\n(XState actors)"]
        STORE["Storage Layer\n(storage.ts)"]
        UI -- user events --> APP
        APP -- data updates --> UI
        APP --> STORE
    end

    H --> Page
    STORE --> SL["browser.storage.local\n(IndexedDB-backed)"]
    APP -- fetch --> OL["Open Library API\n(openlibrary.org)"]
#+end_src
#+RESULTS:
[[file:./images/arch-system-overview.svg]]

Why no background script? The new tab page is a privileged extension page
with full access to all WebExtension APIs including ~browser.storage.local~.
A background script would add complexity without benefit for a single-page,
single-user, local-only app.

** Component responsibilities

#+CAPTION: Component responsibilities
| Component            | Responsibility                                        | Implementation                  |
|----------------------+-------------------------------------------------------+---------------------------------|
| =manifest.json=      | Declares extension; points newtab at HTML; permissions | Static JSON -- no runtime logic |
| =newtab/newtab.html= | Shell document loaded on every new tab open           | Minimal HTML + module script    |
| =newtab/app.ts=      | Orchestrates UI; handles user events; coordinates storage | XState actor root            |
| =newtab/storage.ts=  | Wraps ~browser.storage.local~; owns all read/write    | Thin abstraction layer          |
| =newtab/api.ts=      | Fetches book metadata from Open Library               | Fetch calls, response normalization |
| =newtab/ui/*.ts=     | Renders specific UI sections                          | DOM manipulation or lightweight templating |

* Recommended project structure

#+BEGIN_EXAMPLE
booktab/
├── manifest.json
├── docs/
│   └── decisions/           <- ADRs (MADR 4.0, org-mode format)
│       ├── 0001-vitest.org
│       └── 0002-tdd.org
├── icons/
│   ├── icon-48.png
│   └── icon-96.png
├── src/
│   └── newtab/
│       ├── newtab.html      <- Entry point
│       ├── newtab.css
│       ├── app.ts           <- Orchestrator (XState root actor)
│       ├── storage.ts       <- browser.storage.local abstraction
│       ├── api.ts           <- Open Library fetch wrapper
│       ├── schema.ts        <- Data shape, defaults, migration
│       └── ui/
│           ├── currentBook.ts
│           ├── queue.ts
│           ├── notes.ts
│           ├── history.ts
│           ├── bookForm.ts
│           └── importExport.ts
└── tests/
    └── *.test.ts            <- Vitest specs (public interface only)
#+END_EXAMPLE

Structure rationale:
- *=newtab/= is the entire app* -- no background page, no content scripts,
  no popup
- *=storage.ts= isolation* -- never call ~browser.storage.local~ from UI code;
  centralizing storage makes schema migration and import/export tractable
- *=schema.ts=* -- the single source of truth for data shape, defaults, and
  migration logic
- *=ui/= split by feature* -- each section is a separate module; maps directly
  to product features and phase-by-phase development

* Architectural patterns

** Direct storage from extension page

The new tab page is a privileged extension page and can call
~browser.storage.local.get()~ / ~browser.storage.local.set()~ directly,
without message passing to a background script. Message passing exists for
communication between content scripts and background pages -- unnecessary
overhead here.

#+name: storage-pattern
#+begin_src typescript
// storage.ts
const STORAGE_KEY = 'booktab_data';

export async function loadData(): Promise<BookTabData> {
  const result = await browser.storage.local.get(STORAGE_KEY);
  return result[STORAGE_KEY] ?? getDefaultData();
}

export async function saveData(data: BookTabData): Promise<void> {
  await browser.storage.local.set({ [STORAGE_KEY]: data });
}
#+end_src

** Single root object in storage

Store all app data under one key (=booktab_data=) as a single JSON object,
rather than many individual keys.

Trade-offs:
- *Pro*: Easy to export/import (already one blob), easy to migrate schema,
  atomic reads/writes
- *Con*: Full object re-serialized on every change; fine for <500 books

#+name: schema-pattern
#+begin_src typescript
// schema.ts
export function getDefaultData(): BookTabData {
  return {
    schemaVersion: 1,
    books: {},
    settings: {
      defaultView: 'current'
    }
  };
}
#+end_src

** Storage change listener for multi-tab sync

Use ~browser.storage.local.onChanged~ to reactively update the UI when
storage changes -- handles the case where the user has multiple new tabs
open simultaneously.

#+name: storage-listener
#+begin_src typescript
// app.ts
browser.storage.local.onChanged.addListener((changes) => {
  if (changes.booktab_data) {
    render(changes.booktab_data.newValue);
  }
});
#+end_src

* Data flow

** New tab open (read path)

#+begin_src mermaid :file ./images/arch-read-path.svg :theme neutral
sequenceDiagram
    actor User
    participant Firefox
    participant newtab.html
    participant app.ts
    participant storage.ts
    participant StorageAPI as browser.storage.local

    User->>Firefox: Opens new tab
    Firefox->>newtab.html: Loads extension page
    newtab.html->>app.ts: Initialise (DOMContentLoaded)
    app.ts->>storage.ts: loadData()
    storage.ts->>StorageAPI: get('booktab_data')
    StorageAPI-->>storage.ts: { booktab_data: {...} }
    storage.ts-->>app.ts: BookTabData
    app.ts->>newtab.html: render(data)
    newtab.html-->>User: UI displays current book, queue, etc.
#+end_src
#+RESULTS:
[[file:./images/arch-read-path.svg]]

** User action (write path)

#+begin_src mermaid :file ./images/arch-write-path.svg :theme neutral
sequenceDiagram
    actor User
    participant UI as ui/currentBook.ts
    participant Machine as XState machine
    participant storage.ts
    participant StorageAPI as browser.storage.local
    participant AllTabs as All open new tabs

    User->>UI: Action (e.g. "Mark as Read")
    UI->>Machine: send(event)
    Machine->>Machine: Transition state
    Machine->>storage.ts: saveData(updatedData)
    storage.ts->>StorageAPI: set({ booktab_data: updatedData })
    StorageAPI-->>storage.ts: ok
    StorageAPI->>AllTabs: onChanged fires
    AllTabs->>AllTabs: re-render(newValue)
#+end_src
#+RESULTS:
[[file:./images/arch-write-path.svg]]

** Export flow

#+begin_src mermaid :file ./images/arch-export-path.svg :theme neutral
sequenceDiagram
    actor User
    participant UI as ui/importExport.ts
    participant storage.ts
    participant StorageAPI as browser.storage.local
    participant Browser

    User->>UI: Clicks "Export"
    UI->>storage.ts: loadData()
    storage.ts->>StorageAPI: get('booktab_data')
    StorageAPI-->>storage.ts: BookTabData
    storage.ts-->>UI: BookTabData
    UI->>UI: JSON.stringify(data) → Blob
    UI->>Browser: URL.createObjectURL(blob)
    Browser-->>User: Download dialog (.json file)
#+end_src
#+RESULTS:
[[file:./images/arch-export-path.svg]]

** Import flow

#+begin_src mermaid :file ./images/arch-import-path.svg :theme neutral
flowchart TD
    A([User selects JSON file]) --> B[Read file contents]
    B --> C[JSON.parse]
    C --> D{Valid JSON?}
    D -- No --> E([Reject: show parse error\nStorage untouched])
    D -- Yes --> F[schema.ts.validate\ncheck structure + schemaVersion]
    F --> G{Schema valid?}
    G -- No --> H([Reject: show validation error\nStorage untouched])
    G -- Yes --> I[Auto-backup current data]
    I --> J[Show confirmation dialog]
    J --> K{User confirms?}
    K -- No --> L([Cancelled — Storage untouched])
    K -- Yes --> M[storage.ts.saveData\nimportedData]
    M --> N([Re-render UI\nImport complete])
#+end_src
#+RESULTS:
[[file:./images/arch-import-path.svg]]

* JSON data schema

#+name: booktab-data-schema
#+begin_src typescript
// Full data stored under: browser.storage.local['booktab_data']

interface BookTabData {
  schemaVersion: number;               // Start at 1; increment on breaking changes
  books: Record<string, BookRecord>;   // Keyed by ID -- O(1) lookup
  settings: UserSettings;
}

interface BookRecord {
  id: string;                          // Stable local ID
  // Core metadata
  title: string;
  authors: string[];                   // Array to handle multiple authors
  coverUrl?: string;                   // URL from Open Library (never base64)
  isbn?: string;
  externalId?: string;                 // Open Library key for deduplication
  // Status
  status: 'want_to_read' | 'reading' | 'read';
  // Timestamps (ISO 8601)
  addedAt: string;
  startedAt?: string;                  // When status changed to 'reading'
  finishedAt?: string;                 // When status changed to 'read'
  // Organization
  tags: string[];
  priority: number;                    // Lower = higher priority in queue
  // Notes
  queueNote?: string;                  // "Why I want to read this"
  readingNotes?: string;               // Notes taken during reading
  review?: string;                     // Post-read reflection
}

interface UserSettings {
  defaultView: 'current' | 'queue' | 'history';
}
#+end_src

Schema decisions:
- =books= is an object (keyed by ID), not an array -- O(1) lookup/update
- Tags stored as arrays on each book -- no separate tag store needed at scale
- =priority= is a sortable number -- queue reordering without reshuffling all
  records
- All dates as ISO 8601 strings -- readable in exports, no Date serialization
  issues
- =schemaVersion= field enables data migration between extension updates

* Anti-patterns

** Calling storage from every module

*What people do:* Each UI file calls ~browser.storage.local.get()~ and
~.set()~ directly wherever it needs data.

*Why it's wrong:* Scattered storage calls make schema migrations painful,
import/export logic fragile, and impossible to centralize error handling.

*Do this instead:* All storage access goes through =storage.ts=. UI modules
receive data as parameters and return mutations to =app.ts=.

** Storing books as an array

*What people do:* ~data.books = [{ id: '1', title: ... }, ...]~

*Why it's wrong:* Every update requires ~books.findIndex(b => b.id === id)~
and splicing. With 200+ books it becomes tedious.

*Do this instead:* ~data.books = { [id]: { title: ... } }~. Updates are
~data.books[id].status = 'read'~. Iteration is
~Object.values(data.books).sort(...)~.

** Using window.localStorage

MDN explicitly warns: "Firefox clears data stored by extensions using the
localStorage API in various scenarios where users clear their browsing
history and data for privacy reasons."

*Do this instead:* Always use ~browser.storage.local~.

** Adding a background script for storage coordination

The new tab page is a privileged extension page with full WebExtension API
access. Adding message-passing between UI and storage adds complexity for zero
benefit.

* Scaling considerations

#+CAPTION: Architecture scaling thresholds
| Scale       | Architecture Adjustments                                     |
|-------------+--------------------------------------------------------------|
| 0--100 books  | No changes needed; read/write entire storage object          |
| 100--500 books | Fine; 500-book library with notes is ~200KB; lazy-load covers |
| 500--2000 books | Single-object pattern may feel slow; consider splitting =notes= to separate key |
| 2000+ books  | Unlikely for personal reader; use =unlimitedStorage= permission |

*First bottleneck:* Cover image loading. Always store cover images as URLs
(never base64 blobs). At 500 books, base64 storage would exceed quota.

* Sources

- [[https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Anatomy_of_a_WebExtension][MDN: Anatomy of an extension]] (Jan 16, 2026)
- [[https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/manifest.json/chrome_url_overrides][MDN: chrome_url_overrides]] (Jul 17, 2025)
- [[https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/storage/local][MDN: storage.local]] (Aug 1, 2025)
- [[https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Background_scripts][MDN: Background scripts]] (Jul 17, 2025)
- [[https://extensionworkshop.com/documentation/develop/manifest-v3-migration-guide/][Firefox Extension Workshop: MV3 migration guide]]

---
/Architecture research for: Firefox new tab extension (BookTab)/
/Researched: [2026-02-25 Tue]/
