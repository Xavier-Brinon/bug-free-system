#+title: Architecture Research: BookTab
#+author: BookTab
#+date: [2026-02-25 Tue]
#+startup: indent
#+options: toc:3 num:t ^:{}

- *Domain* :: Firefox browser extension -- new tab page replacement with local
  data storage
- *Researched* :: [2026-02-25 Tue]
- *Confidence* :: HIGH -- all structural claims sourced from MDN official docs
  (updated Jan--Aug 2025)

* Standard architecture

** System overview

For a Firefox new tab extension with local-only storage, there are two viable
architectures. BookTab uses *Architecture A* (no background script) because
the new tab page has full WebExtension API access and can read/write
~browser.storage.local~ directly.

#+BEGIN_EXAMPLE
ARCHITECTURE A (recommended for BookTab)

manifest.json
├── chrome_url_overrides.newtab → newtab/newtab.html
└── permissions: ["storage"]

┌──────────────────────────────────────────────────────────┐
│  newtab/newtab.html  (Extension Page — privileged)        │
│                                                           │
│  ┌────────────┐  ┌──────────────┐  ┌─────────────────┐   │
│  │  UI Layer  │  │  App Logic   │  │  Storage Layer  │   │
│  │ (HTML/CSS) │→ │  (JS modules)│→ │browser.storage  │   │
│  └────────────┘  └──────────────┘  │    .local       │   │
│         ↑               ↑          └────────┬────────┘   │
│         └───────────────┘                   │            │
│              re-render on change            │            │
└──────────────────────────────────────────────────────────┘

External: Open Library API (fetch from page)
#+END_EXAMPLE

Why no background script? The new tab page is a privileged extension page
with full access to all WebExtension APIs including ~browser.storage.local~.
A background script would add complexity without benefit for a single-page,
single-user, local-only app.

** Component responsibilities

#+CAPTION: Component responsibilities
| Component            | Responsibility                                        | Implementation                  |
|----------------------+-------------------------------------------------------+---------------------------------|
| =manifest.json=      | Declares extension; points newtab at HTML; permissions | Static JSON -- no runtime logic |
| =newtab/newtab.html= | Shell document loaded on every new tab open           | Minimal HTML + module script    |
| =newtab/app.ts=      | Orchestrates UI; handles user events; coordinates storage | XState actor root            |
| =newtab/storage.ts=  | Wraps ~browser.storage.local~; owns all read/write    | Thin abstraction layer          |
| =newtab/api.ts=      | Fetches book metadata from Open Library               | Fetch calls, response normalization |
| =newtab/ui/*.ts=     | Renders specific UI sections                          | DOM manipulation or lightweight templating |

* Recommended project structure

#+BEGIN_EXAMPLE
booktab/
├── manifest.json
├── docs/
│   └── decisions/           <- ADRs (MADR 4.0, org-mode format)
│       ├── 0001-vitest.org
│       └── 0002-tdd.org
├── icons/
│   ├── icon-48.png
│   └── icon-96.png
├── src/
│   └── newtab/
│       ├── newtab.html      <- Entry point
│       ├── newtab.css
│       ├── app.ts           <- Orchestrator (XState root actor)
│       ├── storage.ts       <- browser.storage.local abstraction
│       ├── api.ts           <- Open Library fetch wrapper
│       ├── schema.ts        <- Data shape, defaults, migration
│       └── ui/
│           ├── currentBook.ts
│           ├── queue.ts
│           ├── notes.ts
│           ├── history.ts
│           ├── bookForm.ts
│           └── importExport.ts
└── tests/
    └── *.test.ts            <- Vitest specs (public interface only)
#+END_EXAMPLE

Structure rationale:
- *=newtab/= is the entire app* -- no background page, no content scripts,
  no popup
- *=storage.ts= isolation* -- never call ~browser.storage.local~ from UI code;
  centralizing storage makes schema migration and import/export tractable
- *=schema.ts=* -- the single source of truth for data shape, defaults, and
  migration logic
- *=ui/= split by feature* -- each section is a separate module; maps directly
  to product features and phase-by-phase development

* Architectural patterns

** Direct storage from extension page

The new tab page is a privileged extension page and can call
~browser.storage.local.get()~ / ~browser.storage.local.set()~ directly,
without message passing to a background script. Message passing exists for
communication between content scripts and background pages -- unnecessary
overhead here.

#+name: storage-pattern
#+begin_src typescript
// storage.ts
const STORAGE_KEY = 'booktab_data';

export async function loadData(): Promise<BookTabData> {
  const result = await browser.storage.local.get(STORAGE_KEY);
  return result[STORAGE_KEY] ?? getDefaultData();
}

export async function saveData(data: BookTabData): Promise<void> {
  await browser.storage.local.set({ [STORAGE_KEY]: data });
}
#+end_src

** Single root object in storage

Store all app data under one key (=booktab_data=) as a single JSON object,
rather than many individual keys.

Trade-offs:
- *Pro*: Easy to export/import (already one blob), easy to migrate schema,
  atomic reads/writes
- *Con*: Full object re-serialized on every change; fine for <500 books

#+name: schema-pattern
#+begin_src typescript
// schema.ts
export function getDefaultData(): BookTabData {
  return {
    schemaVersion: 1,
    books: {},
    settings: {
      defaultView: 'current'
    }
  };
}
#+end_src

** Storage change listener for multi-tab sync

Use ~browser.storage.local.onChanged~ to reactively update the UI when
storage changes -- handles the case where the user has multiple new tabs
open simultaneously.

#+name: storage-listener
#+begin_src typescript
// app.ts
browser.storage.local.onChanged.addListener((changes) => {
  if (changes.booktab_data) {
    render(changes.booktab_data.newValue);
  }
});
#+end_src

* Data flow

** New tab open (read path)

#+BEGIN_EXAMPLE
User opens new tab
    ↓
Firefox loads newtab.html
    ↓
app.ts initializes → storage.ts.loadData()
    ↓
browser.storage.local.get('booktab_data')
    ↓
data returned → render(data)
    ↓
UI displays: current book, queue, etc.
#+END_EXAMPLE

** User action (write path)

#+BEGIN_EXAMPLE
User action (e.g., "mark as Read")
    ↓
ui/currentBook.ts dispatches event to XState machine
    ↓
Machine transitions state → storage.ts.saveData(updatedData)
    ↓
browser.storage.local.set({ booktab_data: updatedData })
    ↓
storage.onChanged fires → re-render (all open new tabs)
#+END_EXAMPLE

** Export flow

#+BEGIN_EXAMPLE
User clicks "Export"
    ↓
importExport.ts calls storage.ts.loadData()
    ↓
JSON.stringify(data) → Blob
    ↓
Browser download dialog (URL.createObjectURL)
#+END_EXAMPLE

** Import flow

#+BEGIN_EXAMPLE
User selects JSON file
    ↓
importExport.ts reads file → JSON.parse
    ↓
schema.ts.validate(parsed) — check structure + schemaVersion
    ↓
Auto-backup current data → confirm with user
    ↓
storage.ts.saveData(importedData) → re-render
#+END_EXAMPLE

* JSON data schema

#+name: booktab-data-schema
#+begin_src typescript
// Full data stored under: browser.storage.local['booktab_data']

interface BookTabData {
  schemaVersion: number;               // Start at 1; increment on breaking changes
  books: Record<string, BookRecord>;   // Keyed by ID -- O(1) lookup
  settings: UserSettings;
}

interface BookRecord {
  id: string;                          // Stable local ID
  // Core metadata
  title: string;
  authors: string[];                   // Array to handle multiple authors
  coverUrl?: string;                   // URL from Open Library (never base64)
  isbn?: string;
  externalId?: string;                 // Open Library key for deduplication
  // Status
  status: 'want_to_read' | 'reading' | 'read';
  // Timestamps (ISO 8601)
  addedAt: string;
  startedAt?: string;                  // When status changed to 'reading'
  finishedAt?: string;                 // When status changed to 'read'
  // Organization
  tags: string[];
  priority: number;                    // Lower = higher priority in queue
  // Notes
  queueNote?: string;                  // "Why I want to read this"
  readingNotes?: string;               // Notes taken during reading
  review?: string;                     // Post-read reflection
}

interface UserSettings {
  defaultView: 'current' | 'queue' | 'history';
}
#+end_src

Schema decisions:
- =books= is an object (keyed by ID), not an array -- O(1) lookup/update
- Tags stored as arrays on each book -- no separate tag store needed at scale
- =priority= is a sortable number -- queue reordering without reshuffling all
  records
- All dates as ISO 8601 strings -- readable in exports, no Date serialization
  issues
- =schemaVersion= field enables data migration between extension updates

* Anti-patterns

** Calling storage from every module

*What people do:* Each UI file calls ~browser.storage.local.get()~ and
~.set()~ directly wherever it needs data.

*Why it's wrong:* Scattered storage calls make schema migrations painful,
import/export logic fragile, and impossible to centralize error handling.

*Do this instead:* All storage access goes through =storage.ts=. UI modules
receive data as parameters and return mutations to =app.ts=.

** Storing books as an array

*What people do:* ~data.books = [{ id: '1', title: ... }, ...]~

*Why it's wrong:* Every update requires ~books.findIndex(b => b.id === id)~
and splicing. With 200+ books it becomes tedious.

*Do this instead:* ~data.books = { [id]: { title: ... } }~. Updates are
~data.books[id].status = 'read'~. Iteration is
~Object.values(data.books).sort(...)~.

** Using window.localStorage

MDN explicitly warns: "Firefox clears data stored by extensions using the
localStorage API in various scenarios where users clear their browsing
history and data for privacy reasons."

*Do this instead:* Always use ~browser.storage.local~.

** Adding a background script for storage coordination

The new tab page is a privileged extension page with full WebExtension API
access. Adding message-passing between UI and storage adds complexity for zero
benefit.

* Scaling considerations

#+CAPTION: Architecture scaling thresholds
| Scale       | Architecture Adjustments                                     |
|-------------+--------------------------------------------------------------|
| 0--100 books  | No changes needed; read/write entire storage object          |
| 100--500 books | Fine; 500-book library with notes is ~200KB; lazy-load covers |
| 500--2000 books | Single-object pattern may feel slow; consider splitting =notes= to separate key |
| 2000+ books  | Unlikely for personal reader; use =unlimitedStorage= permission |

*First bottleneck:* Cover image loading. Always store cover images as URLs
(never base64 blobs). At 500 books, base64 storage would exceed quota.

* Sources

- [[https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Anatomy_of_a_WebExtension][MDN: Anatomy of an extension]] (Jan 16, 2026)
- [[https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/manifest.json/chrome_url_overrides][MDN: chrome_url_overrides]] (Jul 17, 2025)
- [[https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/storage/local][MDN: storage.local]] (Aug 1, 2025)
- [[https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Background_scripts][MDN: Background scripts]] (Jul 17, 2025)
- [[https://extensionworkshop.com/documentation/develop/manifest-v3-migration-guide/][Firefox Extension Workshop: MV3 migration guide]]

---
/Architecture research for: Firefox new tab extension (BookTab)/
/Researched: [2026-02-25 Tue]/
