---
phase: 03-library-crud
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - src/machines/libraryMachine.ts
  - tests/unit/libraryMachine.test.ts
  - src/schema.ts
  - tests/unit/schema.test.ts
autonomous: true
requirements:
  - LIB-01
  - LIB-02
  - LIB-03
  - LIB-04
  - DEV-05

must_haves:
  truths:
    - "Phase starts with a tidy-up commit (DEV-05) before any new work"
    - "src/schema.ts gains a createBookRecord() factory function for creating new BookRecord objects"
    - "src/machines/libraryMachine.ts exports an XState v5 machine managing CRUD on BookTabData.books"
    - "The machine receives the full BookTabData as input on spawn"
    - "ADD_BOOK event adds a new BookRecord to context.data.books"
    - "UPDATE_BOOK event replaces an existing BookRecord by id"
    - "DELETE_BOOK event removes a BookRecord by id"
    - "SET_STATUS event changes a book's status field"
    - "Every mutation emits a SAVE_NEEDED output event (or invokes a callback) so the parent can persist"
    - "All machine logic written via TDD: tests first, implementation second"
    - "Tests exercise public interfaces only — no internal mocking"
  artifacts:
    - path: "src/machines/libraryMachine.ts"
      provides: "XState v5 library machine: idle state handling ADD_BOOK, UPDATE_BOOK, DELETE_BOOK, SET_STATUS events"
    - path: "tests/unit/libraryMachine.test.ts"
      provides: "Unit tests for all library machine transitions and context mutations"
    - path: "src/schema.ts"
      provides: "Updated with createBookRecord() factory function"
    - path: "tests/unit/schema.test.ts"
      provides: "Updated with tests for createBookRecord()"
  key_links:
    - from: "src/machines/libraryMachine.ts"
      to: "src/schema.ts"
      via: "Imports BookTabData, BookRecord, createBookRecord types/factory"
    - from: "src/machines/libraryMachine.ts"
      to: "src/newtab/App.tsx (Plan 03-04)"
      via: "App spawns libraryMachine when appMachine reaches ready state"
    - from: "src/machines/libraryMachine.ts"
      to: "docs/decisions/0007-xstate.org"
      via: "Machine follows XState v5 pattern from ADR-0007"
---

<objective>
Start Phase 3 with a mandatory tidy-up, then create the library XState machine
that manages all CRUD operations on the books collection. Add a createBookRecord()
factory to schema.ts for generating new book objects with proper defaults.

Purpose: All four LIB requirements (add, edit, delete, status change) need a
central state machine that holds the books collection and applies mutations.
The library machine is a pure logic unit — it takes BookTabData as input,
maintains the books record in context, and emits events when the data needs
persisting. The machine is tested in isolation before any UI is connected.

Output:
- Tidy-up commit
- src/schema.ts updated with createBookRecord() factory
- src/machines/libraryMachine.ts with CRUD operations
- Unit tests for both modules
</objective>

<execution_context>
@/Users/xavierbrinon/.config/Claude/get-shit-done/workflows/execute-plan.md
@/Users/xavierbrinon/.config/Claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.org
@.planning/STATE.org
@.planning/research/ARCHITECTURE.org
@docs/decisions/0007-xstate.org
@docs/decisions/0008-storage-local.org
@src/schema.ts
@src/machines/appMachine.ts
@src/storage.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Phase 3 tidy-up</name>
  <files></files>
  <action>
Mandatory tidy-up before new feature code (DEV-05):

1. Run `npm run lint` and fix any warnings
2. Run `npm run fmt:check` and fix any formatting issues
3. Run `npm test` and confirm all 26 tests pass
4. Review existing code for dead imports, unused variables, inconsistent naming
5. Commit tidy-up changes (if any) as a separate commit
  </action>
  <verify>
    <automated>npm run lint && npm run fmt:check && npm test</automated>
  </verify>
  <done>Codebase is clean; lint, format, and tests all pass; tidy-up commit created (or no changes needed)</done>
</task>

<task type="auto">
  <name>Task 2: Add createBookRecord() factory to schema.ts with TDD</name>
  <files>src/schema.ts
tests/unit/schema.test.ts</files>
  <action>
Write tests first, then implementation. Follow TDD red-green-refactor.

The factory creates a new BookRecord with sensible defaults. It accepts
required fields (title, authors) and optional overrides.

Test 1 (RED): createBookRecord({ title: "Dune", authors: ["Frank Herbert"] })
returns a BookRecord with those values
  → Implement createBookRecord() (GREEN)

Test 2 (RED): createBookRecord() generates a unique id (UUID v4 or crypto.randomUUID())
  → Verify id is a non-empty string (GREEN)

Test 3 (RED): createBookRecord() sets status to 'want_to_read' by default
  → Verify default status (GREEN)

Test 4 (RED): createBookRecord() sets addedAt to current ISO timestamp
  → Verify addedAt is a valid ISO string (GREEN)

Test 5 (RED): createBookRecord() sets empty defaults for tags, priority: 0
  → Verify tags: [], priority: 0 (GREEN)

Test 6 (RED): createBookRecord() allows overriding status and other optional fields
  → Verify override works: createBookRecord({ ..., status: "reading" }) (GREEN)

The function signature should be:
  createBookRecord(input: { title: string; authors: string[]; coverUrl?: string;
    status?: BookStatus; }) => BookRecord

Use crypto.randomUUID() for id generation (available in all modern browsers
and Node 19+).
  </action>
  <verify>
    <automated>npm run test -- --project unit</automated>
  </verify>
  <done>src/schema.ts exports createBookRecord(); all schema tests pass; factory generates valid BookRecord objects with unique ids</done>
</task>

<task type="auto">
  <name>Task 3: Create src/machines/libraryMachine.ts with TDD</name>
  <files>src/machines/libraryMachine.ts
tests/unit/libraryMachine.test.ts</files>
  <action>
Write tests first, then implementation. Follow TDD red-green-refactor.

The library machine manages the books collection within BookTabData. It receives
the current BookTabData as input and maintains the books record in context.

Machine design:
- Single "idle" state (CRUD operations are synchronous context mutations)
- Context: { books: Record<string, BookRecord> }
- Input: BookTabData (extract books from it on creation)
- Events: ADD_BOOK, UPDATE_BOOK, DELETE_BOOK, SET_STATUS
- After each mutation: emit output/callback so parent knows to persist

Test 1 (RED): Machine starts in 'idle' state with books from input
  → Create machine with initial 'idle' state, input mapping (GREEN)

Test 2 (RED): ADD_BOOK event adds a BookRecord to context.books keyed by id
  → Add ADD_BOOK handler with assign action (GREEN)

Test 3 (RED): After ADD_BOOK, the new book is retrievable by its id
  → Verify context.books[id] matches the added book (GREEN)

Test 4 (RED): UPDATE_BOOK event replaces an existing book's fields
  → Add UPDATE_BOOK handler that merges updates into existing book (GREEN)

Test 5 (RED): UPDATE_BOOK for non-existent id does nothing (no crash)
  → Guard or no-op for missing id (GREEN)

Test 6 (RED): DELETE_BOOK event removes a book by id
  → Add DELETE_BOOK handler that deletes from context.books (GREEN)

Test 7 (RED): DELETE_BOOK for non-existent id does nothing
  → Guard or no-op for missing id (GREEN)

Test 8 (RED): SET_STATUS event changes a book's status field
  → Add SET_STATUS handler that updates status on the book (GREEN)

Test 9 (RED): SET_STATUS to 'reading' sets startedAt if not already set
  → Auto-populate startedAt timestamp (GREEN)

Test 10 (RED): SET_STATUS to 'read' sets finishedAt
  → Auto-populate finishedAt timestamp (GREEN)

Test 11 (RED): Machine emits/raises a SAVE_NEEDED action after any mutation
  → Use raise() or sendParent() to signal persistence needed (GREEN)

For testing, use XState's createActor() to drive the machine. Provide initial
BookTabData via input. Inspect context after each event.

Events should carry these payloads:
- ADD_BOOK: { type: "ADD_BOOK"; book: BookRecord }
- UPDATE_BOOK: { type: "UPDATE_BOOK"; id: string; updates: Partial<BookRecord> }
- DELETE_BOOK: { type: "DELETE_BOOK"; id: string }
- SET_STATUS: { type: "SET_STATUS"; id: string; status: BookStatus }
  </action>
  <verify>
    <automated>npm run test -- --project unit</automated>
  </verify>
  <done>src/machines/libraryMachine.ts exports libraryMachine; all library machine tests pass; CRUD events mutate context correctly; SAVE_NEEDED signalled after mutations</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm run lint && npm run fmt:check` pass
2. `npm run test -- --project unit` passes all tests (schema + storage + appMachine + libraryMachine)
3. src/schema.ts exports createBookRecord() factory
4. src/machines/libraryMachine.ts exports libraryMachine with ADD_BOOK, UPDATE_BOOK, DELETE_BOOK, SET_STATUS
5. All mutations update context.books correctly
6. All code written via TDD red-green-refactor
</verification>

<success_criteria>
- Library machine handles all four CRUD operations (LIB-01, LIB-02, LIB-03, LIB-04)
- Machine is testable in isolation without React or browser APIs
- createBookRecord() factory generates valid BookRecord objects
- All stateful logic goes through XState (CORE-04 maintained)
- TDD red-green-refactor followed throughout
</success_criteria>

<output>
After completion, create `.planning/phases/03-library-crud/03-01-SUMMARY.md` using the summary template.
</output>
