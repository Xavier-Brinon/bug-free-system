---
phase: 03-library-crud
plan: "04"
type: execute
wave: 3
depends_on: ["03-02", "03-03"]
files_modified:
  - src/newtab/App.tsx
  - src/newtab/App.css
  - src/newtab/App.stories.tsx
  - src/machines/appMachine.ts
  - src/storage.ts
  - tests/unit/appMachine.test.ts
  - tests/e2e/newtab.spec.ts
autonomous: true
requirements:
  - LIB-01
  - LIB-02
  - LIB-03
  - LIB-04

must_haves:
  truths:
    - "App.tsx renders BookList in the ready state showing all books from storage"
    - "App.tsx renders BookForm when adding or editing a book"
    - "An 'Add Book' button is visible in the ready state"
    - "Submitting BookForm for a new book adds it to storage and shows it in the list"
    - "Clicking Edit on a BookCard opens BookForm pre-filled with that book's data"
    - "Submitting BookForm for an edit updates the book in storage"
    - "Clicking Delete on a BookCard removes the book from storage"
    - "Changing status on a BookCard persists the new status to storage"
    - "All mutations persist via saveBookTabData() and invalidate the TanStack Query cache"
    - "appMachine is extended with UI sub-states (viewing, adding, editing) within ready"
    - "Storybook stories updated to cover new UI states"
    - "Playwright E2E test verifies add → list → delete flow"
  artifacts:
    - path: "src/newtab/App.tsx"
      provides: "Full CRUD UI: BookList + BookForm wired to library machine and storage"
    - path: "src/newtab/App.css"
      provides: "Updated styles for book list, book cards, form layout"
    - path: "src/newtab/App.stories.tsx"
      provides: "Updated stories: Empty, WithBooks, AddingBook, EditingBook"
    - path: "src/machines/appMachine.ts"
      provides: "Extended with ready.viewing, ready.adding, ready.editing sub-states"
    - path: "src/storage.ts"
      provides: "Updated with mutation helpers if needed"
    - path: "tests/unit/appMachine.test.ts"
      provides: "Updated tests for new sub-states"
    - path: "tests/e2e/newtab.spec.ts"
      provides: "E2E test: add a book, verify it appears, delete it"
  key_links:
    - from: "src/newtab/App.tsx"
      to: "src/machines/libraryMachine.ts"
      via: "App uses library machine events for CRUD operations"
    - from: "src/newtab/App.tsx"
      to: "src/components/BookForm.tsx"
      via: "Renders BookForm for add/edit flows"
    - from: "src/newtab/App.tsx"
      to: "src/components/BookList.tsx"
      via: "Renders BookList with books from machine context"
    - from: "src/newtab/App.tsx"
      to: "src/components/BookCard.tsx"
      via: "BookList renders BookCard; App wires callbacks"
    - from: "src/newtab/App.tsx"
      to: "src/storage.ts"
      via: "saveBookTabData() called after library machine mutations"
---

<objective>
Wire all components and machines together into a working CRUD flow. Extend
appMachine with UI sub-states within ready (viewing, adding, editing). Persist
all mutations to browser.storage.local. Update Storybook stories and add a
Playwright E2E test for the full add → list → delete flow.

Purpose: Plans 03-01 through 03-03 created isolated units (machine, form,
list). This plan connects them into the live application. The user can now
add a book, see it in the list, edit it, change its status, and delete it —
with all changes persisted to storage.

Output:
- App.tsx wired with full CRUD flow
- appMachine extended with ready sub-states
- Storybook stories for all UI states
- E2E test for add → list → delete flow
</objective>

<execution_context>
@/Users/xavierbrinon/.config/Claude/get-shit-done/workflows/execute-plan.md
@/Users/xavierbrinon/.config/Claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.org
@.planning/STATE.org
@src/newtab/App.tsx
@src/newtab/App.stories.tsx
@src/machines/appMachine.ts
@src/machines/libraryMachine.ts
@src/components/BookForm.tsx
@src/components/BookList.tsx
@src/components/BookCard.tsx
@src/storage.ts
@src/schema.ts
@tests/e2e/newtab.spec.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend appMachine with ready sub-states (TDD)</name>
  <files>src/machines/appMachine.ts
tests/unit/appMachine.test.ts</files>
  <action>
Write tests first, then implementation. Follow TDD red-green-refactor.

Extend the ready state with sub-states:
- ready.viewing (default): shows BookList
- ready.adding: shows BookForm (empty, add mode)
- ready.editing: shows BookForm (pre-filled, edit mode)

New events:
- START_ADD: ready.viewing → ready.adding
- START_EDIT: ready.viewing → ready.editing (carries bookId in context)
- CANCEL_FORM: ready.adding | ready.editing → ready.viewing
- BOOK_SAVED: ready.adding | ready.editing → ready.viewing

Test 1 (RED): ready state has initial sub-state 'viewing'
  → Add compound state with initial: 'viewing' (GREEN)

Test 2 (RED): START_ADD transitions from ready.viewing to ready.adding
  → Add transition (GREEN)

Test 3 (RED): START_EDIT transitions from ready.viewing to ready.editing
and stores editingBookId in context
  → Add transition with assign (GREEN)

Test 4 (RED): CANCEL_FORM transitions from ready.adding to ready.viewing
  → Add transition (GREEN)

Test 5 (RED): CANCEL_FORM transitions from ready.editing to ready.viewing
and clears editingBookId
  → Add transition with assign (GREEN)

Test 6 (RED): BOOK_SAVED transitions from ready.adding to ready.viewing
  → Add transition (GREEN)

Existing tests must continue passing — the loading and error states are unchanged.
  </action>
  <verify>
    <automated>npm run test -- --project unit</automated>
  </verify>
  <done>appMachine has ready.viewing, ready.adding, ready.editing sub-states; all transitions work; existing tests still pass; editingBookId stored in context during editing</done>
</task>

<task type="auto">
  <name>Task 2: Wire App.tsx with full CRUD flow</name>
  <files>src/newtab/App.tsx
src/newtab/App.css
src/storage.ts</files>
  <action>
Connect all components and machines in App.tsx:

1. Import BookForm, BookList from components
2. Import libraryMachine and createBookRecord from their modules
3. In the ready state rendering:
   - ready.viewing: Render "Add Book" button + BookList
   - ready.adding: Render BookForm (empty)
   - ready.editing: Render BookForm (pre-filled with the book being edited)

4. Wire callbacks:
   - "Add Book" button: send START_ADD to appMachine
   - BookForm onSubmit (add mode):
     a. Create BookRecord via createBookRecord()
     b. Send ADD_BOOK to library machine
     c. Persist updated data via saveBookTabData()
     d. Invalidate TanStack Query cache
     e. Send BOOK_SAVED to appMachine
   - BookForm onSubmit (edit mode):
     a. Send UPDATE_BOOK to library machine
     b. Persist + invalidate + BOOK_SAVED
   - BookForm onCancel: send CANCEL_FORM to appMachine
   - BookCard onEdit: send START_EDIT to appMachine
   - BookCard onDelete:
     a. Send DELETE_BOOK to library machine
     b. Persist + invalidate
   - BookCard onStatusChange:
     a. Send SET_STATUS to library machine
     b. Persist + invalidate

5. Library machine integration:
   - Spawn or use libraryMachine when entering ready state
   - Feed it the loaded BookTabData
   - Read books from library machine context for rendering

6. Persistence pattern:
   After each mutation, reconstruct the full BookTabData object from
   the library machine's context.books + the existing settings/schemaVersion,
   call saveBookTabData(), and invalidate the query cache via
   queryClient.invalidateQueries({ queryKey: QUERY_KEY }).

7. Update App.css with basic styles for the book list, cards, and form layout.

After wiring, verify:
- npm run build succeeds
- npm run test passes all tests
- Manual test: load extension, add a book, see it in the list, edit it,
  change its status, delete it, reload — data persists
  </action>
  <verify>
    <automated>npm run build && npm run test</automated>
  </verify>
  <done>App.tsx renders full CRUD UI; add/edit/delete/status-change all work; data persists to storage; build and tests pass</done>
</task>

<task type="auto">
  <name>Task 3: Update Storybook stories</name>
  <files>src/newtab/App.stories.tsx</files>
  <action>
Update App.stories.tsx to cover the new UI states. Keep existing stories
(Loading, Ready, ErrorState) and add new ones:

1. Empty story (renamed from Ready): ready.viewing with no books
2. WithBooks: ready.viewing with 2-3 sample books in different statuses
3. AddingBook: ready.adding with BookForm visible
4. EditingBook: ready.editing with BookForm pre-filled

For WithBooks, mock the query to return BookTabData with sample books.
For AddingBook/EditingBook, either mock the machine state or set up the
QueryClient to return data that triggers the right state.

Also add component-level stories for BookForm, BookCard, BookList in
separate story files:
- src/components/BookForm.stories.tsx (empty form, pre-filled form)
- src/components/BookCard.stories.tsx (want to read, reading, read statuses)
- src/components/BookList.stories.tsx (empty, with books)

Verify:
- npm run storybook builds and renders all stories
- Vitest storybook project passes all story tests
  </action>
  <verify>
    <automated>npm run test</automated>
  </verify>
  <done>All stories render; storybook builds; vitest storybook project passes</done>
</task>

<task type="auto">
  <name>Task 4: Playwright E2E test for CRUD flow</name>
  <files>tests/e2e/newtab.spec.ts</files>
  <action>
Add an E2E test that exercises the full CRUD flow in the built extension:

1. Build the extension (npm run build)
2. Load extension in Chromium via launchPersistentContext
3. Navigate to a new tab
4. Verify "No books yet" empty state is visible
5. Click "Add Book"
6. Fill in title and author
7. Submit the form
8. Verify the book appears in the list
9. Click Delete on the book
10. Verify the book is removed and empty state returns

This test exercises the full stack: UI → XState → TanStack Query → storage.
Keep the existing smoke test. Add the CRUD test as a new test case.

NOTE: Since Playwright loads the real extension, browser.storage.local is
a real extension storage API. The test exercises actual persistence.
  </action>
  <verify>
    <automated>npm run e2e</automated>
  </verify>
  <done>E2E test passes: add book → verify in list → delete → verify empty; existing smoke test still passes</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm run lint && npm run fmt:check` pass
2. `npm run test` passes all tests (unit + browser + storybook)
3. `npm run e2e` passes all E2E tests
4. `npm run build` succeeds
5. Extension loads in Firefox: user can add, edit, delete books; changes persist
6. Storybook shows all component states
7. All four LIB requirements are satisfied end-to-end
</verification>

<success_criteria>
- User can add a book manually (LIB-01 ✓)
- User can set a book's status (LIB-02 ✓)
- User can edit a book's details (LIB-03 ✓)
- User can delete a book (LIB-04 ✓)
- All mutations persist to browser.storage.local
- All stateful logic goes through XState machines
- Storybook stories cover all UI states
- E2E test verifies the full CRUD flow
</success_criteria>

<output>
After completion, create `.planning/phases/03-library-crud/03-04-SUMMARY.md` using the summary template.
</output>
