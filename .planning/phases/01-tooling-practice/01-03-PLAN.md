---
phase: 01-tooling-practice
plan: "03"
type: execute
wave: 2
depends_on:
  - "01-01"
files_modified:
  - docs/decisions/0001-vitest.org
  - docs/decisions/images/0001-vitest-toolchain.svg
  - docs/decisions/0002-tdd.org
  - docs/decisions/images/0002-tdd-cycle.svg
  - docs/decisions/0003-react.org
  - docs/decisions/images/0003-react-component-model.svg
  - docs/decisions/0004-tanstack-query.org
  - docs/decisions/images/0004-tanstack-storage-flow.svg
  - docs/decisions/0005-storybook.org
autonomous: true
requirements:
  - DEV-02
  - DEV-03
  - DEV-04
  - DEV-06

must_haves:
  truths:
    - "An ADR exists documenting why Vitest was chosen over alternatives (Jest, Mocha)"
    - "An ADR exists documenting the TDD red-green-refactor methodology and its constraints"
    - "An ADR exists documenting why React 19 was chosen over Vanilla TS and Preact"
    - "An ADR exists documenting why TanStack Query wraps browser.storage.local"
    - "An ADR exists documenting the Storybook decision and why installation is deferred to Phase 2"
    - "All five ADRs have status: Accepted and follow MADR 4.0 org-mode format"
    - "ADRs 0001-0004 include Mermaid diagrams (ob-mermaid syntax with :file header)"
    - "A contributor reading docs/decisions/ can understand every architectural choice made so far"
  artifacts:
    - path: "docs/decisions/0001-vitest.org"
      provides: "ADR for test framework: Vitest chosen over Jest/Mocha; includes toolchain diagram"
      contains: "Status: Accepted"
    - path: "docs/decisions/images/0001-vitest-toolchain.svg"
      provides: "Rendered or placeholder SVG of Vitest toolchain integration diagram"
    - path: "docs/decisions/0002-tdd.org"
      provides: "ADR for TDD methodology: constraints documented (public interface only, no bulk tests)"
      contains: "Status: Accepted"
    - path: "docs/decisions/images/0002-tdd-cycle.svg"
      provides: "Rendered or placeholder SVG of red-green-refactor cycle flowchart"
    - path: "docs/decisions/0003-react.org"
      provides: "ADR for React 19 as UI layer; Vanilla TS and Preact considered and rejected"
      contains: "Status: Accepted"
    - path: "docs/decisions/images/0003-react-component-model.svg"
      provides: "Rendered or placeholder SVG of React + XState + TanStack Query component model"
    - path: "docs/decisions/0004-tanstack-query.org"
      provides: "ADR for TanStack Query wrapping browser.storage.local; SWR considered and rejected"
      contains: "Status: Accepted"
    - path: "docs/decisions/images/0004-tanstack-storage-flow.svg"
      provides: "Rendered or placeholder SVG of TanStack Query / storage.local data flow"
    - path: "docs/decisions/0005-storybook.org"
      provides: "ADR for Storybook; explains why setup is deferred to Phase 2"
      contains: "Status: Accepted"
  key_links:
    - from: "docs/decisions/0001-vitest.org"
      to: "vitest.config.ts (Plan 02)"
      via: "ADR documents the decision already implemented in Plan 02"
      pattern: "Decision Outcome.*Vitest"
    - from: "docs/decisions/0002-tdd.org"
      to: "CONTRIBUTING.org (Plan 01)"
      via: "ADR provides architectural rationale for rules captured in CONTRIBUTING.org"
      pattern: "red-green-refactor"
    - from: "docs/decisions/0003-react.org"
      to: "package.json (Plan 02)"
      via: "ADR documents the React install decision implemented in Plan 02"
      pattern: "Decision Outcome.*React"
    - from: "docs/decisions/0004-tanstack-query.org"
      to: "package.json (Plan 02)"
      via: "ADR documents the TanStack Query install decision implemented in Plan 02"
      pattern: "Decision Outcome.*TanStack"
---

<objective>
Write the five foundational ADRs that document all stack decisions made before
Phase 2 begins. Each ADR captures the decision that was already made and
implemented in Plans 01-01 and 01-02. ADRs 0001-0004 include Mermaid diagrams.

Purpose: ADR-02 and ADR-03 require that every architecturally significant decision
has a written ADR before Phase 2 starts. These five ADRs cover: test framework,
TDD methodology, React 19 as UI layer, TanStack Query for async storage, and
Storybook for component isolation. Without them, the next executor begins Phase 2
without a documented rationale for the stack choices.

Output:
- docs/decisions/0001-vitest.org — ADR for Vitest (status: Accepted) with toolchain diagram
- docs/decisions/0002-tdd.org — ADR for TDD methodology (status: Accepted) with cycle diagram
- docs/decisions/0003-react.org — ADR for React 19 (status: Accepted) with component model diagram
- docs/decisions/0004-tanstack-query.org — ADR for TanStack Query (status: Accepted) with storage flow diagram
- docs/decisions/0005-storybook.org — ADR for Storybook (status: Accepted)
- Placeholder SVGs for all diagram blocks (generated or placeholder)

Prerequisites: docs/decisions/ and docs/decisions/images/ must exist (created in Plan 01-01).
</objective>

<execution_context>
@/Users/xavierbrinon/.config/Claude/get-shit-done/workflows/execute-plan.md
@/Users/xavierbrinon/.config/Claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.org
@.planning/STATE.org
@.planning/research/STACK.org
@.planning/phases/01-tooling-practice/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write ADR-0001 (Vitest) and ADR-0002 (TDD methodology)</name>
  <files>docs/decisions/0001-vitest.org
docs/decisions/images/0001-vitest-toolchain.svg
docs/decisions/0002-tdd.org
docs/decisions/images/0002-tdd-cycle.svg</files>
  <action>
Copy the structure from docs/decisions/0000-template.org and create each ADR.
All content must be accurate based on actual project constraints from STACK.org
and STATE.org. Use org-mode format throughout -- no markdown.

--- ADR-0001: Vitest ---

Title: Use Vitest as the test framework
Status: Accepted

Context: BookTab is a TypeScript project built with Vite 7. We need a test
framework for TDD red-green-refactor. The framework must support native ESM
(no CommonJS transform), TypeScript without additional configuration, jsdom
environment for React component tests, and fast execution for tight feedback.

Decision Drivers:
- Native ESM support (no jest.config transform setup)
- Same configuration as Vite (no parallel config maintenance)
- Fast execution for tight TDD feedback loop
- TypeScript support without Babel/ts-jest
- jsdom environment for React component tests (@testing-library/react)
- Actively maintained (2025/2026)

Considered Options: Vitest, Jest (with ts-jest or Babel transform), Mocha + Chai

Decision Outcome: Chosen: Vitest. Shares Vite's configuration, supports native
ESM and TypeScript without transforms, jsdom environment built-in, Jest-compatible
API (easy for contributors familiar with Jest).

Positive Consequences: No transform setup; fast startup; stable API; jsdom
environment works out-of-the-box for React tests.

Negative Consequences: Requires Vite in toolchain (already a dependency).

Include this Mermaid diagram block (ob-mermaid syntax, :file required):

  #+begin_src mermaid :file ./images/0001-vitest-toolchain.svg :theme neutral
  graph LR
      TS["TypeScript source\n(src/**/*.ts, .tsx)"]
      TESTS["Test files\n(tests/**/*.test.ts, .tsx)"]
      VITE["vite.config.ts\n(Vite 7)"]
      VCFG["vitest.config.ts\n(jsdom environment)"]
      VITEST["Vitest runner\n(npm run test)"]
      OUT["Test results\npass / fail"]

      TS --> VCFG
      TESTS --> VCFG
      VITE --> VCFG
      VCFG --> VITEST
      VITEST --> OUT
  #+end_src
  #+RESULTS:
  [[file:./images/0001-vitest-toolchain.svg]]

--- ADR-0002: TDD red-green-refactor ---

Title: Adopt TDD red-green-refactor vertical slicing for all features
Status: Accepted

Context: BookTab needs a consistent testing approach. Without a documented
methodology, tests tend to be written in bulk after implementation (reducing
their value as design tools), or they test internal implementation details
(making refactoring costly).

Decision Drivers:
- Tests should drive design, not verify existing code
- No tests written in bulk after implementation (DEV-03)
- Tests must survive refactoring without rewrite: public interface only (DEV-04)
- One cohesive behaviour tested per cycle (vertical slice)
- Each phase must begin with a cleanup pass (DEV-05)

Considered Options:
- Red-green-refactor vertical slicing (one test → one implementation → repeat)
- Spec-first (write all tests, then all implementation)
- Test-after (write implementation, then tests)

Decision Outcome: Chosen: Red-green-refactor vertical slicing. Keeps test and
implementation in sync, forces each test to be written when behaviour is freshest
in mind, and produces tests coupled to public behaviour (not internal structure).

Specific constraints (in Positive Consequences):
1. One test written → run (must fail, RED) → minimal implementation to pass
   (GREEN) → refactor if needed → repeat
2. No writing multiple tests before any implementation
3. Tests call only public exports -- no importing private functions, no
   mocking internals
4. Each phase begins with a tidy-up commit before any new feature work

Negative Consequences: Slower initial velocity on simple features vs.
write-all-tests-first. Accepted: design quality and refactor safety outweigh speed.

Include this Mermaid diagram block:

  #+begin_src mermaid :file ./images/0002-tdd-cycle.svg :theme neutral
  flowchart LR
      A([Start:\nnew behaviour]) --> B
      B["Write one\nfailing test"] --> C
      C(["Run test\nsuite"])
      C --> D{Result?}
      D -- RED\nfail --> E["Write minimal\nimplementation"]
      E --> F(["Run test\nsuite"])
      F --> G{Result?}
      G -- RED\nstill failing --> E
      G -- GREEN\npassing --> H{"Refactor\nneeded?"}
      H -- Yes --> I["Refactor\n(keep tests green)"]
      I --> J(["Run test\nsuite"])
      J --> K{Result?}
      K -- GREEN --> L([Next\nbehaviour])
      K -- RED --> I
      H -- No --> L
  #+end_src
  #+RESULTS:
  [[file:./images/0002-tdd-cycle.svg]]

For both ADRs: after writing the org file, generate the SVG by running ob-mermaid
(C-c C-c in Emacs). If running in a non-Emacs environment, create placeholder SVGs:
  echo '<svg xmlns="http://www.w3.org/2000/svg"><text y="20">Run ob-mermaid C-c C-c to generate</text></svg>' > docs/decisions/images/0001-vitest-toolchain.svg
  echo '<svg xmlns="http://www.w3.org/2000/svg"><text y="20">Run ob-mermaid C-c C-c to generate</text></svg>' > docs/decisions/images/0002-tdd-cycle.svg
  </action>
  <verify>
    <automated>ls docs/decisions/0001-vitest.org docs/decisions/0002-tdd.org docs/decisions/images/0001-vitest-toolchain.svg docs/decisions/images/0002-tdd-cycle.svg && grep -i "accepted" docs/decisions/0001-vitest.org && grep -i "accepted" docs/decisions/0002-tdd.org && grep "mermaid" docs/decisions/0001-vitest.org && grep "mermaid" docs/decisions/0002-tdd.org</automated>
  </verify>
  <done>0001-vitest.org and 0002-tdd.org exist with Status: Accepted; both contain MADR 4.0 sections; both have Mermaid diagram blocks with :file header; SVG files exist in images/</done>
</task>

<task type="auto">
  <name>Task 2: Write ADR-0003 (React 19) and ADR-0004 (TanStack Query)</name>
  <files>docs/decisions/0003-react.org
docs/decisions/images/0003-react-component-model.svg
docs/decisions/0004-tanstack-query.org
docs/decisions/images/0004-tanstack-storage-flow.svg</files>
  <action>
Copy the structure from docs/decisions/0000-template.org and create each ADR.
Use org-mode format throughout -- no markdown.

--- ADR-0003: React 19 as UI rendering layer ---

Title: Use React 19 as the UI rendering layer
Status: Accepted

Context: The original STACK.org recommendation was Vanilla TypeScript with
Preact as an upgrade path. During Phase 1 planning the actual UI scope was
evaluated: 4--6 distinct views (new tab hero, library list, book detail, queue,
search, import/export), stateful forms, conditional rendering driven by XState
machines, and async data from browser.storage.local. This complexity justifies
a proper component model. The original "no heavy frameworks if avoidable"
constraint in PROJECT.org has been superseded by this decision.

Decision Drivers:
- @xstate/react (useMachine, useSelector) is the official XState React binding;
  Preact compatibility is unofficial and lags
- TanStack Query has first-class React support; Preact adapter is
  community-maintained
- Storybook supports React as a first-class framework; Preact requires manual
  configuration
- 4--6 view UI with stateful forms benefits from a component model
- React 19 bundle cost (~45 KB) is acceptable for an extension that loads on
  user demand (new tab), not on every page load

Considered Options:
- React 19
- Vanilla TypeScript + CSS
- Preact 10.x

Decision Outcome: Chosen: React 19. @xstate/react and TanStack Query have
first-class React support. The UI scope (multi-view, stateful forms, XState
integration) justifies the component model. Bundle size is acceptable.

Positive Consequences: Official @xstate/react hooks; first-class TanStack Query;
Storybook works out-of-the-box; component isolation aids testing.

Negative Consequences: ~45 KB runtime bundle (acceptable). Vanilla TS would be
smaller but would require hand-rolled view switching, state synchronization, and
DOM manipulation across 4--6 views.

Include this Mermaid diagram block:

  #+begin_src mermaid :file ./images/0003-react-component-model.svg :theme neutral
  graph TD
      subgraph XState["XState v5 Machines"]
          M1["appMachine\n(view routing)"]
          M2["bookMachine\n(CRUD state)"]
      end

      subgraph TanStack["TanStack Query"]
          Q1["useBooks()\n(cache + storage.local)"]
          Q2["useMutation()\n(optimistic updates)"]
      end

      subgraph React["React 19 Components"]
          C1["NewTabPage"]
          C2["LibraryView"]
          C3["BookDetail"]
          C4["QueueView"]
      end

      M1 -- useSelector --> C1
      M2 -- useMachine --> C2
      Q1 -- data --> C2
      Q1 -- data --> C3
      Q2 -- mutate --> C2
      C1 --> C2
      C1 --> C3
      C1 --> C4
  #+end_src
  #+RESULTS:
  [[file:./images/0003-react-component-model.svg]]

--- ADR-0004: TanStack Query for async storage access ---

Title: Use TanStack Query to wrap browser.storage.local
Status: Accepted

Context: browser.storage.local is an async API. Without a structured async data
layer, every component that reads storage must manage its own loading, error, and
success states -- leading to duplicated code, race conditions on tab open, and
stale data after mutations. We need a solution that handles this consistently.

Decision Drivers:
- Eliminate async race condition on new tab open (critical pitfall from PITFALLS.org)
- Consistent loading/error/success states across all components
- Cache invalidation via browser.storage.onChanged listener
- Optimistic updates for fast UI on mutations (add/edit/delete book)
- Avoid manual refetch coordination between components

Considered Options:
- TanStack Query (React Query v5) wrapping browser.storage.local
- SWR wrapping browser.storage.local
- Manual useEffect + useState per component

Decision Outcome: Chosen: TanStack Query. First-class React support; robust cache
invalidation pattern; optimistic updates built-in; no Redux/Context boilerplate.
SWR is a valid alternative but TanStack Query has richer mutation support and
better TypeScript inference.

Positive Consequences: Single source of truth for async storage state; race
condition on tab open handled by query loading state; cache invalidated via
browser.storage.onChanged → queryClient.invalidateQueries().

Negative Consequences: Adds ~47 KB (compressed) to the bundle. Accepted: the
async state management complexity it replaces would require equivalent custom code.

No TanStack Router -- XState machine state drives view switching instead
(3--4 views is below the threshold where a router adds value over a machine).

Include this Mermaid diagram block:

  #+begin_src mermaid :file ./images/0004-tanstack-storage-flow.svg :theme neutral
  sequenceDiagram
      participant C as React Component
      participant Q as TanStack Query
      participant S as browser.storage.local
      participant E as storage.onChanged

      C->>Q: useBooks() / useQuery
      Q->>S: storage.local.get('booktab_data')
      S-->>Q: { books, schemaVersion }
      Q-->>C: { data, isLoading, isError }

      Note over C,Q: User adds a book
      C->>Q: addBook mutation
      Q->>S: storage.local.set(updated)
      S-->>E: onChanged event fires
      E->>Q: queryClient.invalidateQueries()
      Q->>S: refetch
      S-->>Q: updated data
      Q-->>C: fresh data rendered
  #+end_src
  #+RESULTS:
  [[file:./images/0004-tanstack-storage-flow.svg]]

For both ADRs: generate SVGs with ob-mermaid (C-c C-c in Emacs), or create
placeholder SVGs if in a non-Emacs environment:
  echo '<svg xmlns="http://www.w3.org/2000/svg"><text y="20">Run ob-mermaid C-c C-c to generate</text></svg>' > docs/decisions/images/0003-react-component-model.svg
  echo '<svg xmlns="http://www.w3.org/2000/svg"><text y="20">Run ob-mermaid C-c C-c to generate</text></svg>' > docs/decisions/images/0004-tanstack-storage-flow.svg
  </action>
  <verify>
    <automated>ls docs/decisions/0003-react.org docs/decisions/0004-tanstack-query.org docs/decisions/images/0003-react-component-model.svg docs/decisions/images/0004-tanstack-storage-flow.svg && grep -i "accepted" docs/decisions/0003-react.org && grep -i "accepted" docs/decisions/0004-tanstack-query.org && grep "mermaid" docs/decisions/0003-react.org && grep "mermaid" docs/decisions/0004-tanstack-query.org</automated>
  </verify>
  <done>0003-react.org and 0004-tanstack-query.org exist with Status: Accepted; both have Mermaid diagram blocks with :file header; SVG placeholders exist in images/; content accurately reflects the decisions made during planning</done>
</task>

<task type="auto">
  <name>Task 3: Write ADR-0005 (Storybook)</name>
  <files>docs/decisions/0005-storybook.org</files>
  <action>
Copy the structure from docs/decisions/0000-template.org and create
docs/decisions/0005-storybook.org.

Use org-mode format throughout -- no markdown.

Title: Use Storybook for component isolation and visual development
Status: Accepted

Context: BookTab has 4--6 React views and several shared UI components
(book card, status badge, search input, empty state). Without component
isolation tooling, developers must load the full extension to see a component
in various states -- slowing feedback and making edge-case states hard to
reproduce (e.g., empty library, loading state, error state).

Decision Drivers:
- Isolated component development without running the full extension
- Visual documentation of all component states (including loading, empty, error)
- Visual regression testing via Storybook's snapshot testing (no Chromatic
  cloud service needed -- local snapshots only)
- React is a first-class Storybook framework (Vite builder supported)

Considered Options:
- Storybook (Vite builder, React framework)
- No isolation tooling (develop components in context of full extension only)
- Ladle (lightweight Storybook alternative)

Decision Outcome: Chosen: Storybook. React and Vite are both first-class in
Storybook. Preact (the original alternative) would have required manual
configuration. Ladle is a viable lightweight alternative but has fewer
integrations and a smaller community.

Installation timing: Storybook is NOT installed in Phase 1. No React components
exist yet -- a Storybook with zero stories has no value and adds setup noise
before any UI work begins. Installation is deferred to Phase 2 when the first
component is created.

Positive Consequences: Isolated component development; visual state documentation;
local snapshot regression testing; no external cloud dependency.

Negative Consequences: ~5-10 MB dev dependency footprint; separate dev server
(npm run storybook). Acceptable in a dev-only context.

No Mermaid diagram needed for this ADR -- the decision is not a flow or
dependency graph.
  </action>
  <verify>
    <automated>ls docs/decisions/0005-storybook.org && grep -i "accepted" docs/decisions/0005-storybook.org && grep -i "phase 2\|deferred" docs/decisions/0005-storybook.org</automated>
  </verify>
  <done>0005-storybook.org exists with Status: Accepted; explains installation is deferred to Phase 2; covers Storybook vs Ladle vs no tooling comparison; all MADR 4.0 sections present; valid org-mode format</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `ls docs/decisions/` shows: README.org, 0000-template.org, 0001-vitest.org, 0002-tdd.org, 0003-react.org, 0004-tanstack-query.org, 0005-storybook.org, images/
2. `ls docs/decisions/images/` shows SVG files for 0001, 0002, 0003, 0004 (placeholder or rendered)
3. All five ADRs have "Status" heading with "Accepted" value
4. ADRs 0001-0004 each contain a mermaid src block with :file header argument
5. ADR-0003 references @xstate/react and TanStack Query as decision drivers
6. ADR-0004 references browser.storage.local and cache invalidation via storage.onChanged
7. ADR-0005 states installation is deferred to Phase 2
8. All files are valid org-mode (#+title: header present, * headings, no markdown syntax)
</verification>

<success_criteria>
- ADR-0001 (Vitest) written and accepted (DEV-06 ✓)
- ADR-0002 (TDD) written and accepted with specific constraints (DEV-02, DEV-03, DEV-04, DEV-06 ✓)
- ADR-0003 (React 19) written and accepted -- supersedes "no heavy frameworks" guideline
- ADR-0004 (TanStack Query) written and accepted -- storage async strategy documented
- ADR-0005 (Storybook) written and accepted -- deferred to Phase 2 documented
- All ADRs follow MADR 4.0 org-mode format from the template
- ADRs 0001-0004 include ob-mermaid diagram blocks with :file header arguments
- A contributor reading docs/decisions/ understands every architectural choice made in Phase 1
</success_criteria>

<output>
After completion, create `.planning/phases/01-tooling-practice/01-03-SUMMARY.md` using the summary template.
</output>
