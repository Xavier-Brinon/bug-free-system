---
phase: 04-new-tab-display
plan: "03"
type: execute
wave: 2
depends_on: ["04-01", "04-02"]
files_modified:
  - src/newtab/App.tsx
  - src/newtab/App.css
autonomous: true
requirements:
  - DISP-01
  - DISP-02
  - DISP-03

must_haves:
  truths:
    - "When a book has 'reading' status, CurrentlyReading hero is rendered prominently in the ready.viewing state"
    - "When no book has 'reading' status, EmptyHero is rendered instead of CurrentlyReading"
    - "QueueCount is always visible in the ready.viewing state regardless of whether a book is being read"
    - "The 'Add Book' button remains accessible in the dashboard layout"
    - "The BookList continues to render below the hero section showing all books"
    - "If multiple books have 'reading' status, the first one (by addedAt) is shown in the hero"
    - "Switching a book to 'reading' status immediately updates the hero display (no stale state)"
    - "Switching a book away from 'reading' status shows EmptyHero if no other book is 'reading'"
    - "The dashboard layout is structured: hero section → queue count → book list"
    - "All existing CRUD functionality (add, edit, delete, status change) continues to work"
    - "All existing tests continue to pass — no regressions"
  artifacts:
    - path: "src/newtab/App.tsx"
      provides: "Dashboard layout: CurrentlyReading/EmptyHero hero + QueueCount + BookList"
    - path: "src/newtab/App.css"
      provides: "Updated styles for dashboard layout, hero section, queue count positioning"
  key_links:
    - from: "src/newtab/App.tsx"
      to: "src/components/CurrentlyReading.tsx"
      via: "Renders CurrentlyReading when a book has 'reading' status"
    - from: "src/newtab/App.tsx"
      to: "src/components/EmptyHero.tsx"
      via: "Renders EmptyHero when no book has 'reading' status"
    - from: "src/newtab/App.tsx"
      to: "src/components/QueueCount.tsx"
      via: "Renders QueueCount with count of 'want_to_read' books"
    - from: "src/newtab/App.tsx"
      to: "src/components/BookList.tsx"
      via: "BookList still rendered below the hero section"
    - from: "src/newtab/App.tsx"
      to: "src/machines/libraryMachine.ts"
      via: "Reads books from library machine context to derive hero book and queue count"
---

<objective>
Wire the new Phase 4 components (CurrentlyReading, EmptyHero, QueueCount)
into App.tsx to create the dashboard layout for the new tab page. Transform
the ready.viewing state from a flat book list into a structured dashboard.

Purpose: Plans 04-01 and 04-02 created isolated display components. This plan
connects them into the live application, fulfilling DISP-01 (hero display),
DISP-02 (empty state), and DISP-03 (queue count) end-to-end.

Output:
- App.tsx refactored with dashboard layout in ready.viewing
- App.css updated with hero, queue count, and layout styles
- All existing CRUD functionality preserved
</objective>

<execution_context>
@/Users/xavierbrinon/.config/Claude/get-shit-done/workflows/execute-plan.md
@/Users/xavierbrinon/.config/Claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.org
@.planning/STATE.org
@src/newtab/App.tsx
@src/newtab/App.css
@src/components/CurrentlyReading.tsx
@src/components/EmptyHero.tsx
@src/components/QueueCount.tsx
@src/components/BookList.tsx
@src/components/BookCard.tsx
@src/machines/appMachine.ts
@src/machines/libraryMachine.ts
@src/schema.ts
@src/storage.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Derive hero book and queue count from library data</name>
  <files>src/newtab/App.tsx</files>
  <action>
In the ready.viewing rendering section of App.tsx, compute:

1. currentlyReading: The book with status "reading". If multiple books have
   "reading" status, use the one with the earliest addedAt timestamp (first
   one started). If none, this is null.

2. queueCount: The number of books with status "want_to_read".

These are derived values computed from the books record each render — no new
state or machine changes needed. Use Object.values(books) and filter/find.

Implementation:
```typescript
const allBooks = Object.values(books);
const currentlyReading = allBooks
  .filter(b => b.status === "reading")
  .sort((a, b) => a.addedAt.localeCompare(b.addedAt))[0] ?? null;
const queueCount = allBooks.filter(b => b.status === "want_to_read").length;
```

These computations are simple enough to live inline in App.tsx. No separate
utility file needed.
  </action>
  <verify>
    <automated>npm run build && npm run test</automated>
  </verify>
  <done>currentlyReading and queueCount derived from books record; build passes; existing tests pass</done>
</task>

<task type="auto">
  <name>Task 2: Refactor ready.viewing layout to dashboard</name>
  <files>src/newtab/App.tsx
src/newtab/App.css</files>
  <action>
Replace the flat layout in ready.viewing with a structured dashboard:

BEFORE (current):
```
<h1>BookTab</h1>
<button>Add Book</button>
<BookList ... />
```

AFTER (dashboard):
```
<h1>BookTab</h1>
<section class="hero-section">
  {currentlyReading
    ? <CurrentlyReading book={currentlyReading} onStatusChange={...} onEdit={...} onDelete={...} />
    : <EmptyHero onStartAdding={() => send({ type: "START_ADD" })} />}
</section>
<QueueCount count={queueCount} />
<button>Add Book</button>
<BookList ... />
```

Wire the CurrentlyReading callbacks to the existing handlers:
- onStatusChange → handleStatusChange
- onEdit → handleEdit
- onDelete → handleDelete

Wire EmptyHero:
- onStartAdding → send START_ADD to appMachine

Update App.css with styles for:
- .hero-section: prominent placement, generous padding, centred
- .currently-reading: large title font, distinct background/border
- .empty-hero: centred prompt, inviting design
- .queue-count: visible badge, positioned between hero and list

Ensure the "Add Book" button remains accessible and BookList still renders
below the hero section.

After wiring, verify all existing tests pass — no CRUD regressions.
  </action>
  <verify>
    <automated>npm run build && npm run test</automated>
  </verify>
  <done>Dashboard layout renders hero/empty state + queue count + book list; all existing CRUD works; build and tests pass</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm run lint && npm run fmt:check` pass
2. `npm run test` passes all tests (unit + browser + storybook)
3. `npm run build` succeeds
4. ready.viewing shows CurrentlyReading hero when a book has "reading" status
5. ready.viewing shows EmptyHero when no book has "reading" status
6. QueueCount always visible with correct count
7. All CRUD operations still work (add, edit, delete, status change)
8. No stale state after status changes
</verification>

<success_criteria>
- Current book shown prominently on new tab (DISP-01 ✓)
- Empty state shown when no book is Reading (DISP-02 ✓)
- To-read count visible on new tab (DISP-03 ✓)
- All existing Phase 3 functionality preserved
- Dashboard layout is structured and visually clear
</success_criteria>

<output>
After completion, create `.planning/phases/04-new-tab-display/04-03-SUMMARY.md` using the summary template.
</output>
