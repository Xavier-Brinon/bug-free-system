---
phase: 05-queue
plan: "03"
type: execute
wave: 2
depends_on: ["05-01", "05-02"]
files_modified:
  - src/machines/appMachine.ts
  - tests/unit/appMachine.test.ts
  - src/newtab/App.tsx
  - src/newtab/App.css
  - src/newtab/App.stories.tsx
  - src/components/QueueList.stories.tsx
  - src/components/QueueNoteEditor.stories.tsx
  - tests/e2e/newtab.spec.ts
autonomous: true
requirements:
  - QUEUE-01
  - QUEUE-02

must_haves:
  truths:
    - "appMachine gains ready.viewingQueue and ready.editingNote substates"
    - "VIEW_QUEUE event navigates from ready.viewing to ready.viewingQueue"
    - "BACK_TO_DASHBOARD event navigates from ready.viewingQueue to ready.viewing"
    - "EDIT_NOTE event navigates to ready.editingNote with the target book id"
    - "NOTE_SAVED event persists the note and returns to ready.viewingQueue"
    - "App.tsx renders QueueList in viewingQueue state"
    - "App.tsx renders QueueNoteEditor in editingNote state"
    - "Note persistence uses UPDATE_BOOK on the libraryMachine via persistAndInvalidate"
    - "Dashboard has a 'View Queue' navigation element"
    - "Storybook stories exist for QueueList, QueueNoteEditor, and App queue states"
    - "Playwright E2E tests verify queue navigation, note editing, and persistence"
  artifacts:
    - path: "src/machines/appMachine.ts"
      provides: "Extended with viewingQueue and editingNote substates"
    - path: "tests/unit/appMachine.test.ts"
      provides: "Unit tests for new queue-related state transitions"
    - path: "src/newtab/App.tsx"
      provides: "Queue view and note editing wired into the app"
    - path: "src/newtab/App.css"
      provides: "Styles for queue view and note editor"
    - path: "src/newtab/App.stories.tsx"
      provides: "Stories for App in queue and note-editing states"
    - path: "src/components/QueueList.stories.tsx"
      provides: "Storybook stories for QueueList component"
    - path: "src/components/QueueNoteEditor.stories.tsx"
      provides: "Storybook stories for QueueNoteEditor component"
    - path: "tests/e2e/newtab.spec.ts"
      provides: "E2E tests for queue navigation, note editing, persistence"
  key_links:
    - from: "src/newtab/App.tsx"
      to: "src/components/QueueList.tsx"
      via: "Renders QueueList in viewingQueue state"
    - from: "src/newtab/App.tsx"
      to: "src/components/QueueNoteEditor.tsx"
      via: "Renders QueueNoteEditor in editingNote state"
    - from: "src/newtab/App.tsx"
      to: "src/machines/appMachine.ts"
      via: "Uses new queue-related events and states"
    - from: "src/newtab/App.tsx"
      to: "src/machines/libraryMachine.ts"
      via: "Uses UPDATE_BOOK to persist queueNote"
---

<objective>
Wire the QueueList and QueueNoteEditor components into the app by extending
the appMachine with queue navigation states and integrating everything into
App.tsx. Add Storybook stories and Playwright E2E tests.

Purpose: This plan completes both QUEUE-01 and QUEUE-02 by connecting the
queue components to the state machine and persistence layer. Users can navigate
to a dedicated queue view from the dashboard, see only their want_to_read books,
add/edit intention notes, and have those notes persist across sessions.

Output:
- Extended appMachine with viewingQueue and editingNote states
- Unit tests for new state transitions
- App.tsx integration with queue navigation and note editing
- CSS styles for queue view
- Storybook stories for all new components and App states
- Playwright E2E tests for queue workflows
</objective>

<execution_context>
@/Users/xavierbrinon/.config/Claude/get-shit-done/workflows/execute-plan.md
@/Users/xavierbrinon/.config/Claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.org
@.planning/STATE.org
@src/machines/appMachine.ts
@tests/unit/appMachine.test.ts
@src/newtab/App.tsx
@src/newtab/App.css
@src/newtab/App.stories.tsx
@src/components/QueueList.tsx
@src/components/QueueNoteEditor.tsx
@tests/e2e/newtab.spec.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend appMachine with queue states (TDD, unit tests)</name>
  <files>src/machines/appMachine.ts
tests/unit/appMachine.test.ts</files>
  <action>
Write unit tests first, then implementation. Follow TDD red-green-refactor.

New states and events for appMachine:
  - ready.viewingQueue — shows the queue list
  - ready.editingNote — shows the note editor for a specific book

New events:
  - VIEW_QUEUE: ready.viewing → ready.viewingQueue
  - BACK_TO_DASHBOARD: ready.viewingQueue → ready.viewing
  - EDIT_NOTE: ready.viewingQueue → ready.editingNote (stores editingNoteBookId in context)
  - NOTE_SAVED: ready.editingNote → ready.viewingQueue (clears editingNoteBookId)
  - CANCEL_NOTE: ready.editingNote → ready.viewingQueue (clears editingNoteBookId)

Context additions:
  - editingNoteBookId: string | null

Test 1 (RED): VIEW_QUEUE transitions from ready.viewing to ready.viewingQueue
  → Add viewingQueue substate and VIEW_QUEUE event (GREEN)

Test 2 (RED): BACK_TO_DASHBOARD transitions from ready.viewingQueue to ready.viewing
  → Add BACK_TO_DASHBOARD event (GREEN)

Test 3 (RED): EDIT_NOTE transitions to ready.editingNote with book id in context
  → Add editingNote substate, EDIT_NOTE event, editingNoteBookId context (GREEN)

Test 4 (RED): NOTE_SAVED transitions back to ready.viewingQueue and clears editingNoteBookId
  → Add NOTE_SAVED event handler (GREEN)

Test 5 (RED): CANCEL_NOTE transitions back to ready.viewingQueue and clears editingNoteBookId
  → Add CANCEL_NOTE event handler (GREEN)

Refactor: ensure clean types, consistent with existing appMachine patterns.
  </action>
  <verify>
    <automated>npm run test -- --project unit</automated>
  </verify>
  <done>appMachine has viewingQueue and editingNote substates; all unit tests pass</done>
</task>

<task type="auto">
  <name>Task 2: Wire queue view and note editing into App.tsx</name>
  <files>src/newtab/App.tsx
src/newtab/App.css</files>
  <action>
Integrate QueueList and QueueNoteEditor into the App component.

1. Import QueueList and QueueNoteEditor components
2. Add handleSaveNote callback:
   - Uses libraryMachine UPDATE_BOOK with { queueNote } to update the note
   - Calls persistAndInvalidate to save to storage
   - Sends NOTE_SAVED to appMachine
3. In ready.viewing, add a "View Queue" button/link that sends VIEW_QUEUE
4. Add ready.viewingQueue render:
   - Shows "Your Queue" heading
   - "Back to Dashboard" button → sends BACK_TO_DASHBOARD
   - Renders QueueList with books, action callbacks, and onEditNote that sends EDIT_NOTE
5. Add ready.editingNote render:
   - Shows QueueNoteEditor with the target book's existing queueNote
   - Save callback calls handleSaveNote
   - Cancel callback sends CANCEL_NOTE
6. Add CSS styles for queue view layout (queue-view class)

Ensure the queue view also includes the Add Book button for convenience.
  </action>
  <verify>
    <automated>npm run build && npm run lint && npm run fmt:check</automated>
  </verify>
  <done>App renders queue view and note editor based on appMachine state; builds cleanly</done>
</task>

<task type="auto">
  <name>Task 3: Storybook stories for queue components and App states</name>
  <files>src/components/QueueList.stories.tsx
src/components/QueueNoteEditor.stories.tsx
src/newtab/App.stories.tsx</files>
  <action>
Add Storybook stories following existing patterns.

QueueList stories:
  - WithQueuedBooks: shows 2-3 queued books with notes
  - EmptyQueue: shows empty state message
  - MixedStatuses: full books record, only want_to_read shown

QueueNoteEditor stories:
  - EmptyNote: blank textarea for new note
  - ExistingNote: pre-filled textarea with existing note

App stories (add to existing file):
  - QueueView: App in ready.viewingQueue state with queued books
  - EditingNote: App in ready.editingNote state
  </action>
  <verify>
    <automated>npm run test -- --project storybook</automated>
  </verify>
  <done>All new Storybook stories render correctly; storybook tests pass</done>
</task>

<task type="auto">
  <name>Task 4: Playwright E2E tests for queue workflows</name>
  <files>tests/e2e/newtab.spec.ts</files>
  <action>
Add E2E tests to the existing newtab.spec.ts file.

Test 1: User can navigate to queue view and see queued books
  - Add a book with want_to_read status
  - Click "View Queue"
  - Verify the book appears in the queue list
  - Click "Back to Dashboard" to return

Test 2: User can add an intention note to a queued book
  - Add a book with want_to_read status
  - Navigate to queue view
  - Click edit note on the book
  - Type a note in the textarea
  - Save the note
  - Verify the note text appears in the queue view

Test 3: Queue note persists across page reloads
  - Add a book, navigate to queue, add a note, save
  - Reload the page
  - Navigate to queue view
  - Verify the note text is still displayed
  </action>
  <verify>
    <automated>npm run e2e</automated>
  </verify>
  <done>E2E tests pass for queue navigation, note editing, and persistence</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm run lint && npm run fmt:check` pass
2. `npm run test` passes all tests (unit + browser + storybook)
3. `npm run build` succeeds
4. `npm run e2e` passes all E2E tests
5. User can navigate to queue view from dashboard
6. Queue view shows only want_to_read books
7. User can add/edit intention notes that persist
8. Notes are visible when viewing queued books
</verification>

<success_criteria>
- Full QUEUE-01: Queue view lists only want_to_read books, navigable from dashboard
- Full QUEUE-02: Intention notes can be added, edited, and persist across sessions
- Notes visible in book details without extra navigation
- TDD red-green-refactor followed throughout
</success_criteria>

<output>
After completion, create `.planning/phases/05-queue/05-03-SUMMARY.md` using the summary template.
</output>
