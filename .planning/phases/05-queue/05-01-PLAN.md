---
phase: 05-queue
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/QueueList.tsx
  - tests/browser/QueueList.test.tsx
autonomous: true
requirements:
  - QUEUE-01
  - DEV-05

must_haves:
  truths:
    - "Phase starts with a tidy-up commit (DEV-05) before any new work"
    - "QueueList component filters books to show only want_to_read status"
    - "QueueList renders each queued book using BookCard"
    - "QueueList shows an empty state message when no books are queued"
    - "QueueList receives onEdit, onDelete, onStatusChange, and onEditNote callbacks"
    - "All component logic written via TDD: browser tests first, implementation second"
    - "Tests exercise public interfaces only — no internal mocking"
  artifacts:
    - path: "src/components/QueueList.tsx"
      provides: "Filtered list component showing only want_to_read books with empty state"
    - path: "tests/browser/QueueList.test.tsx"
      provides: "Browser tests for QueueList filtering, rendering, and empty state"
  key_links:
    - from: "src/components/QueueList.tsx"
      to: "src/schema.ts"
      via: "Imports BookRecord and BookStatus types"
    - from: "src/components/QueueList.tsx"
      to: "src/components/BookCard.tsx"
      via: "Renders each queued book via BookCard"
    - from: "src/components/QueueList.tsx"
      to: "src/newtab/App.tsx (Plan 05-03)"
      via: "App renders QueueList in the queue view state"
---

<objective>
Start Phase 5 with mandatory tidy-up, then build the QueueList component that
displays only want_to_read books in a dedicated filtered list.

Purpose: QUEUE-01 requires users to view all Want to Read books in a list —
not mixed with books in other states. This component receives the full books
record, filters to want_to_read only, and renders each using BookCard. It shows
a helpful empty state when no books are queued.

Output:
- Tidy-up commit
- src/components/QueueList.tsx — filtered queue list component
- Browser tests for filtering, rendering, and empty state
</objective>

<execution_context>
@/Users/xavierbrinon/.config/Claude/get-shit-done/workflows/execute-plan.md
@/Users/xavierbrinon/.config/Claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.org
@.planning/STATE.org
@src/schema.ts
@src/components/BookCard.tsx
@src/components/BookList.tsx
@src/newtab/App.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Phase 5 tidy-up</name>
  <files></files>
  <action>
Mandatory tidy-up before new feature code (DEV-05):

1. Run `npm run lint` and fix any warnings
2. Run `npm run fmt:check` and fix any formatting issues
3. Run `npm test` and confirm all 100 tests pass
4. Review existing code for dead imports, unused variables, inconsistent naming
5. Commit tidy-up changes (if any) as a separate commit
  </action>
  <verify>
    <automated>npm run lint && npm run fmt:check && npm test</automated>
  </verify>
  <done>Codebase is clean; lint, format, and tests all pass; tidy-up commit created (or no changes needed)</done>
</task>

<task type="auto">
  <name>Task 2: Build QueueList component with TDD (browser tests)</name>
  <files>src/components/QueueList.tsx
tests/browser/QueueList.test.tsx</files>
  <action>
Write browser tests first, then implementation. Follow TDD red-green-refactor.

The QueueList component renders a filtered list of want_to_read books.
Props:
  - books: Record&lt;string, BookRecord&gt; (all books — component filters internally)
  - onEdit: (id: string) => void
  - onDelete: (id: string) => void
  - onStatusChange: (id: string, status: BookStatus) => void
  - onEditNote: (id: string) => void

Test 1 (RED): Renders only want_to_read books, not reading or read books
  → Create component that filters books by status, renders with BookCard (GREEN)

Test 2 (RED): Shows empty state message when no books have want_to_read status
  → Add conditional empty state rendering (GREEN)

Test 3 (RED): Shows empty state when books record is entirely empty
  → Handles edge case of empty books object (GREEN)

Test 4 (RED): Renders an "Edit Note" button for each queued book
  → Add onEditNote button that calls callback with book id (GREEN)

Test 5 (RED): Displays the queue note text when a book has a queueNote
  → Show queueNote text inline beneath each book entry (GREEN)

Refactor pass: ensure clean prop types, consistent naming with other list components.
  </action>
  <verify>
    <automated>npm run test -- --project browser</automated>
  </verify>
  <done>QueueList component filters and renders want_to_read books; empty state works; note display and edit button present; all browser tests pass</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm run lint && npm run fmt:check` pass
2. `npm run test` passes all tests (unit + browser + storybook)
3. `npm run build` succeeds
4. QueueList only renders want_to_read books
5. Empty state shown when no queued books
6. Queue note text visible when present
7. All code written via TDD red-green-refactor
</verification>

<success_criteria>
- QueueList displays only Want to Read books (QUEUE-01 partial)
- Empty state shown when queue is empty
- Queue note visible in book details area
- TDD red-green-refactor followed throughout
</success_criteria>

<output>
After completion, create `.planning/phases/05-queue/05-01-SUMMARY.md` using the summary template.
</output>
