---
phase: 02-extension-scaffold
plan: "04"
type: execute
wave: 3
depends_on: ["02-02", "02-03"]
files_modified:
  - src/machines/appMachine.ts
  - src/newtab/App.tsx
  - tests/unit/appMachine.test.ts
autonomous: true
requirements:
  - CORE-04

must_haves:
  truths:
    - "src/machines/appMachine.ts exports an XState v5 machine with loading, ready, and error states"
    - "The machine starts in loading state"
    - "The machine transitions from loading to ready when data is available"
    - "The machine transitions from loading to error on storage failure"
    - "The machine transitions from error back to loading on retry"
    - "App.tsx uses @xstate/react hooks to render based on machine state"
    - "Loading state renders a loading indicator — no interactive elements before data resolves"
    - "No ad-hoc boolean flags (isLoading, hasError) in component code"
    - "All machine logic written via TDD: tests first, implementation second"
  artifacts:
    - path: "src/machines/appMachine.ts"
      provides: "XState v5 app machine: loading → ready (on DATA_LOADED) / error (on DATA_FAILED); error → loading (on RETRY)"
    - path: "src/newtab/App.tsx"
      provides: "Updated App component rendering loading/ready/error states based on XState machine"
    - path: "tests/unit/appMachine.test.ts"
      provides: "Unit tests for all machine transitions"
  key_links:
    - from: "src/machines/appMachine.ts"
      to: "src/newtab/App.tsx"
      via: "@xstate/react hooks (useMachine or useActorRef)"
      pattern: "import { useMachine } from '@xstate/react'"
    - from: "src/newtab/App.tsx"
      to: "src/storage.ts"
      via: "App observes TanStack Query state and sends events to machine"
      pattern: "useBookTabData() → DATA_LOADED / DATA_FAILED events"
    - from: "src/machines/appMachine.ts"
      to: "docs/decisions/0007-xstate.org"
      via: "Machine implements the loading → ready → error pattern from ADR-0007"
---

<objective>
Create the XState v5 app machine that manages the application lifecycle. Wire
it into React via @xstate/react. The app shows a loading state until storage
resolves, then renders a "ready" view. Error state offers retry.

Purpose: CORE-04 requires all stateful logic to flow through XState v5
machines. The app machine replaces ad-hoc boolean flags (isLoading, hasError,
isReady) with an explicit state diagram. The loading → ready transition gates
user interaction behind data availability — preventing the async race condition
pitfall.

Output:
- src/machines/appMachine.ts with loading → ready → error states
- App.tsx updated to render based on machine state via @xstate/react
- Unit tests for all machine transitions
</objective>

<execution_context>
@/Users/xavierbrinon/.config/Claude/get-shit-done/workflows/execute-plan.md
@/Users/xavierbrinon/.config/Claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.org
@.planning/STATE.org
@docs/decisions/0007-xstate.org
@docs/decisions/0004-tanstack-query.org
@.planning/research/ARCHITECTURE.org
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create src/machines/appMachine.ts with TDD</name>
  <files>src/machines/appMachine.ts
tests/unit/appMachine.test.ts</files>
  <action>
Write tests first, then implementation. Follow TDD red-green-refactor.

The app machine manages the application lifecycle:
- States: loading (initial), ready, error
- Events: DATA_LOADED (with BookTabData payload), DATA_FAILED (with error), RETRY

Test 1 (RED): Machine starts in 'loading' state
  → Create machine with initial: 'loading' (GREEN)

Test 2 (RED): Machine transitions from 'loading' to 'ready' on DATA_LOADED event
  → Add transition loading → ready on DATA_LOADED (GREEN)

Test 3 (RED): Machine transitions from 'loading' to 'error' on DATA_FAILED event
  → Add transition loading → error on DATA_FAILED (GREEN)

Test 4 (RED): Machine transitions from 'error' to 'loading' on RETRY event
  → Add transition error → loading on RETRY (GREEN)

Test 5 (RED): Machine does NOT transition from 'ready' on DATA_FAILED event
  (ready state should be stable — errors during ready are handled differently)
  → Verify no transition (GREEN)

Test 6 (RED): DATA_LOADED event carries BookTabData context
  → Add context/event typing (GREEN)

Test 7 (RED): Machine stores BookTabData in context when entering 'ready'
  → Add assign action on DATA_LOADED (GREEN)

Use XState v5 createMachine() API. The machine should:
- Be typed with TypeScript (context, events)
- Store BookTabData in context when in 'ready' state
- Be testable without React (pure machine logic)

For testing, use XState's createActor() and actor.send() to drive transitions.
Do NOT test through React components — that happens in Plan 02-04 Task 2.
  </action>
  <verify>
    <automated>npm run test -- --project unit</automated>
  </verify>
  <done>src/machines/appMachine.ts exports appMachine with loading/ready/error states; all unit tests pass; machine transitions verified for all events</done>
</task>

<task type="auto">
  <name>Task 2: Wire machine into App.tsx via @xstate/react</name>
  <files>src/newtab/App.tsx</files>
  <action>
Update src/newtab/App.tsx to:

1. Import useMachine (or useActor) from '@xstate/react'
2. Import appMachine from '../machines/appMachine'
3. Import useBookTabData from '../storage' (TanStack Query hook)
4. Use the machine to drive rendering:

function App() {
  const [state, send] = useMachine(appMachine);
  const { data, isLoading, isError, error } = useBookTabData();

  // Bridge TanStack Query state to XState machine events
  useEffect(() => {
    if (data && !isLoading) {
      send({ type: 'DATA_LOADED', data });
    }
    if (isError) {
      send({ type: 'DATA_FAILED', error });
    }
  }, [data, isLoading, isError, error, send]);

  // Render based on machine state
  if (state.matches('loading')) {
    return <div className="app"><p>Loading your library...</p></div>;
  }
  if (state.matches('error')) {
    return (
      <div className="app">
        <p>Something went wrong.</p>
        <button onClick={() => send({ type: 'RETRY' })}>Retry</button>
      </div>
    );
  }
  // ready state
  return (
    <div className="app">
      <h1>BookTab</h1>
      <p>Your library is ready. No books yet.</p>
    </div>
  );
}

Key points:
- TanStack Query handles the async data fetching
- The machine receives events based on query state
- Rendering is purely driven by machine state — no ad-hoc boolean checks
- The loading state gates all user interaction
- The button click handler uses send() — no inline JS in HTML

After wiring, verify:
- npm run build succeeds
- npm run test passes all tests (unit + any existing)
- Extension loads in Firefox: shows loading briefly, then ready state
  </action>
  <verify>
    <automated>npm run build && npm run test</automated>
  </verify>
  <done>App.tsx renders based on machine state; loading shows "Loading your library..."; ready shows "Your library is ready"; error shows retry button; npm run build and npm run test both pass</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm run test -- --project unit` passes all machine tests
2. `npm run build` succeeds
3. src/machines/appMachine.ts exports a machine with loading/ready/error states
4. src/newtab/App.tsx uses @xstate/react hooks — no ad-hoc useState for state management
5. Extension loads in Firefox: loading state visible briefly, then ready state renders
6. No boolean flags (isLoading, hasError, isReady) used for rendering decisions — machine state only
</verification>

<success_criteria>
- All stateful logic wired through XState v5 machine (CORE-04 ✓)
- No ad-hoc flags manage async transitions
- Loading state prevents user interaction before data is available
- Machine transitions are tested via TDD
- App renders based on explicit machine states (loading/ready/error)
</success_criteria>

<output>
After completion, create `.planning/phases/02-extension-scaffold/02-04-SUMMARY.md` using the summary template.
</output>
