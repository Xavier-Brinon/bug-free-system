---
phase: 06-data-safety
plan: "02"
type: execute
wave: 1
depends_on: ["06-01"]
files_modified:
  - src/data-safety.ts
  - tests/unit/data-safety.test.ts
autonomous: true
requirements:
  - DATA-01
  - DATA-02
  - DATA-03

must_haves:
  truths:
    - "exportToJson returns pretty-printed JSON string of BookTabData"
    - "parseImportFile validates JSON against bookTabDataSchema using Zod safeParse"
    - "parseImportFile returns success with parsed data for valid input"
    - "parseImportFile returns failure with user-friendly error for invalid input"
    - "generateExportFilename produces timestamped filename like booktab-export-YYYY-MM-DD.json"
    - "generateBackupFilename produces timestamped filename like booktab-backup-YYYY-MM-DD.json"
    - "triggerDownload creates Blob and programmatic anchor click for file download"
    - "All pure functions written via TDD: unit tests first, implementation second"
    - "Tests exercise public interfaces only — no internal mocking"
  artifacts:
    - path: "src/data-safety.ts"
      provides: "Pure utility functions for export, import validation, download trigger, and filename generation"
    - path: "tests/unit/data-safety.test.ts"
      provides: "Unit tests for all pure data-safety functions"
  key_links:
    - from: "src/data-safety.ts"
      to: "src/schema.ts"
      via: "Imports bookTabDataSchema and BookTabData for validation and typing"
    - from: "src/data-safety.ts"
      to: "src/components/DataManager.tsx (Plan 06-03)"
      via: "DataManager component calls these utilities"
    - from: "src/data-safety.ts"
      to: "src/newtab/App.tsx (Plan 06-04)"
      via: "App.tsx orchestrates export/import flows using these utilities"
---

<objective>
Build the pure utility functions for data export, import validation, filename
generation, and file download triggering — all with TDD unit tests.

Purpose: These functions implement the core logic for DATA-01 (export),
DATA-02 (import validation), and DATA-03 (backup filename generation). They
are pure functions (except triggerDownload) that can be thoroughly unit tested
before being wired into components.

Output:
- src/data-safety.ts — export, import validation, download, filename utilities
- tests/unit/data-safety.test.ts — comprehensive unit tests
</objective>

<execution_context>
@/Users/xavierbrinon/.config/Claude/get-shit-done/workflows/execute-plan.md
@/Users/xavierbrinon/.config/Claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.org
@.planning/STATE.org
@src/schema.ts
@src/storage.ts
@docs/decisions/0010-json-schema.org
</context>

<tasks>

<task type="auto">
  <name>Task 1: exportToJson with TDD (unit tests)</name>
  <files>src/data-safety.ts
tests/unit/data-safety.test.ts</files>
  <action>
Write unit test first, then implementation. Follow TDD red-green-refactor.

Function: exportToJson(data: BookTabData): string
- Returns JSON.stringify(data, null, 2) for human-readable output
- Preserves all fields: schemaVersion, books (with all record fields), settings

Test 1 (RED): exportToJson returns pretty-printed JSON string with correct structure
  - Create a BookTabData object with 2 books
  - Call exportToJson, parse result back, verify equality
  -> Implement exportToJson (GREEN)

Test 2 (RED): exportToJson output includes schemaVersion field
  - Verify the parsed output has schemaVersion: 1
  -> Already passes (GREEN) — verify and refactor if needed

Test 3 (RED): exportToJson output is parseable back to valid BookTabData
  - Round-trip test: exportToJson -> JSON.parse -> bookTabDataSchema.safeParse -> success
  -> Already passes (GREEN) — verify and refactor if needed
  </action>
  <verify>
    <automated>npm run test -- --project unit</automated>
  </verify>
  <done>exportToJson function implemented with TDD; unit tests pass</done>
</task>

<task type="auto">
  <name>Task 2: parseImportFile with TDD (unit tests)</name>
  <files>src/data-safety.ts
tests/unit/data-safety.test.ts</files>
  <action>
Write unit tests first, then implementation. Follow TDD red-green-refactor.

Function: parseImportFile(content: string): { success: true; data: BookTabData } | { success: false; error: string }
- Parses JSON string and validates against bookTabDataSchema
- Returns discriminated union for success/failure

Test 1 (RED): parseImportFile returns success with data for valid exported JSON
  - Use exportToJson output as input to parseImportFile
  -> Implement basic parseImportFile with JSON.parse + safeParse (GREEN)

Test 2 (RED): parseImportFile returns failure for invalid JSON string
  - Pass "not json at all" as input
  - Expect { success: false, error containing "Invalid JSON" }
  -> Add try/catch around JSON.parse (GREEN)

Test 3 (RED): parseImportFile returns failure for valid JSON with wrong shape
  - Pass JSON.stringify({ foo: "bar" }) as input
  - Expect { success: false, error containing "Invalid" or descriptive message }
  -> Zod safeParse handles this (GREEN)

Test 4 (RED): parseImportFile returns failure for missing schemaVersion
  - Pass JSON.stringify({ books: {}, settings: { defaultView: "current" } })
  - Expect failure
  -> Zod validation catches this (GREEN)

Test 5 (RED): parseImportFile returns failure for empty string
  - Pass "" as input
  - Expect failure with descriptive error
  -> JSON.parse catch handles this (GREEN)

Refactor: ensure error messages are user-friendly, not raw Zod output.
  </action>
  <verify>
    <automated>npm run test -- --project unit</automated>
  </verify>
  <done>parseImportFile implemented with TDD; handles valid data, invalid JSON, wrong shape, missing fields; all unit tests pass</done>
</task>

<task type="auto">
  <name>Task 3: Filename generators with TDD (unit tests)</name>
  <files>src/data-safety.ts
tests/unit/data-safety.test.ts</files>
  <action>
Write unit tests first, then implementation. Follow TDD red-green-refactor.

Functions:
- generateExportFilename(): string — returns "booktab-export-YYYY-MM-DD.json"
- generateBackupFilename(): string — returns "booktab-backup-YYYY-MM-DD.json"

Test 1 (RED): generateExportFilename returns string matching pattern booktab-export-YYYY-MM-DD.json
  - Call generateExportFilename()
  - Assert matches regex /^booktab-export-\d{4}-\d{2}-\d{2}\.json$/
  -> Implement using new Date().toISOString().slice(0, 10) (GREEN)

Test 2 (RED): generateBackupFilename returns string matching pattern booktab-backup-YYYY-MM-DD.json
  - Call generateBackupFilename()
  - Assert matches regex /^booktab-backup-\d{4}-\d{2}-\d{2}\.json$/
  -> Implement same pattern with "backup" prefix (GREEN)
  </action>
  <verify>
    <automated>npm run test -- --project unit</automated>
  </verify>
  <done>Filename generators implemented with TDD; unit tests pass</done>
</task>

<task type="auto">
  <name>Task 4: triggerDownload implementation</name>
  <files>src/data-safety.ts</files>
  <action>
Implement triggerDownload as a DOM side-effect function. This function is not
unit-testable in Node (requires DOM) — it will be tested at the E2E level.

Function: triggerDownload(content: string, filename: string): void
1. Create a Blob with type "application/json"
2. Create an object URL via URL.createObjectURL
3. Create an anchor element, set href and download attributes
4. Programmatically click the anchor
5. Revoke the object URL to free memory

This is a thin wrapper around DOM APIs — no business logic to test.
  </action>
  <verify>
    <automated>npm run build</automated>
  </verify>
  <done>triggerDownload implemented; builds without errors</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm run lint && npm run fmt:check` pass
2. `npm run test` passes all tests (existing 124 + new unit tests)
3. `npm run build` succeeds
4. exportToJson, parseImportFile, generateExportFilename, generateBackupFilename, triggerDownload all implemented
5. All pure functions have TDD unit tests
6. Round-trip test confirms export -> import produces identical data
</verification>

<success_criteria>
- Export produces human-readable, re-importable JSON (DATA-01 partial)
- Import validates against Zod schema with user-friendly errors (DATA-02 partial)
- Backup filename generation works (DATA-03 partial)
- TDD red-green-refactor followed throughout
</success_criteria>

<output>
After completion, create `.planning/phases/06-data-safety/06-02-SUMMARY.md` using the summary template.
</output>
